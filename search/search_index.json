{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ChemGymRL's documentation!","title":"Home"},{"location":"#welcome-to-chemgymrls-documentation","text":"","title":"Welcome to ChemGymRL's documentation!"},{"location":"About/","text":"About","title":"About"},{"location":"About/#about","text":"","title":"About"},{"location":"Contact/","text":"Contact Us","title":"Contact Us"},{"location":"Contact/#contact-us","text":"","title":"Contact Us"},{"location":"Developers/","text":"Developers","title":"Developers"},{"location":"Developers/#developers","text":"","title":"Developers"},{"location":"Directory/","text":"Directory","title":"Directory"},{"location":"Directory/#directory","text":"","title":"Directory"},{"location":"Glossary/","text":"Glossary","title":"Glossary"},{"location":"Glossary/#glossary","text":"","title":"Glossary"},{"location":"Installation/","text":"Installation","title":"Installation"},{"location":"Installation/#installation","text":"","title":"Installation"},{"location":"License/","text":"Citation & License","title":"Citation and Licence"},{"location":"License/#citation-license","text":"","title":"Citation &amp; License"},{"location":"Output/","text":"Output","title":"Output"},{"location":"Output/#output","text":"","title":"Output"},{"location":"QuickStart/","text":"Quick Start","title":"Quick Start"},{"location":"QuickStart/#quick-start","text":"","title":"Quick Start"},{"location":"RLalgo/","text":"Examples of Reinforcement Learning Algorithm Running and Results","title":"Examples of RL algoritm and Results"},{"location":"RLalgo/#examples-of-reinforcement-learning-algorithm-running-and-results","text":"","title":"Examples of Reinforcement Learning Algorithm Running and Results"},{"location":"Troubleshooting/","text":"Troubleshooting Hello","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting-hello","text":"","title":"Troubleshooting Hello"},{"location":"Tutorial1/","text":"Reaction Bench Tutorial","title":"Tutorial1"},{"location":"Tutorial1/#reaction-bench-tutorial","text":"","title":"Reaction Bench Tutorial"},{"location":"Tutorial2/","text":"Extraction Bench Tutorial","title":"Tutorial2"},{"location":"Tutorial2/#extraction-bench-tutorial","text":"","title":"Extraction Bench Tutorial"},{"location":"Tutorial3/","text":"Distillation Bench: Lesson 1 Familiarizing Actions for the Distillation Bench In this tutorial, I will teach you how the distillation environment works. In this distillation we are taking the tests/test_extract_vessel.pickle which is a pickle file generated when we ran the extraction bench. It is important to know that before running the distillation bench, you must first complete both reaction and extraction, in order to follow the workflow our environment. To find out more, take a look at the readme.md file on our github. Start by running /tests/demo_lesson_1d.py and you should see a series of graphs appear: These graphs show the contents of our containers. There are 3 main containers: - boiling vessel - beaker 1 - beaker 2 The boiling vessel contains all the materials at the initial state of the experiment. Beaker 1 can be thought of as a condensation vessel which is connected to the distillation vessel via a tube and this will contain all the materials that are being boiled off. Beaker 2 is then the storage vessel, where the condensation vessel can be emptied, in order to make room for other material. Now after we load in our desired environment, we should be prompted with a message asking us to pick our desired action and the multiplier. Let me explain what this means by taking a look at our action space. Our action space is given by a matrix of shape {0, 1} n_action x multiplier . The agent at each time step essentially picks from a set of actions, and then a multiplier for that given action. The multiplier affects each action differently. For example the way the agents chosen multiplier affects heat change is by the following code: In this case the heat change is affected by both the user's chosen multiplier and the dQ which is an attribute for the maximum change in thermal energy. Typically, an agent will choose actions based on what will give a higher reward, and higher rewards are given by getting a high molar amount of the desired material, in this case, dodecane, as well as a high purity in one particular vessel. From a chemistry point of view, what's happening is that the agent is extracting a material from the boiling vessel, which contains multiple materials, and it does this by utilizing the different material's boiling points. The experiment begins by raising the temperature of the boiling vessel which will allow certain materials in that vessel to boil off into the condensation vessel/beaker 1. The amount of energy required to raise the temperature of the materials in the vessel are dependent on their specific heat properties, which can be found in the chemistrylab/chem_algorithms/material.py file. As more heat is added we will eventually reach the lowest boiling point of the materials in the vessel, and any more heat added will act to evaporate this material. The now gaseous material will rise out of the boiling vessel into the tube that feeds into the condensation vessel where it will condense back into its liquid form. In this virtual experiment it is assumed that this takes place instantaneously. The amount of material evaporated is dependent on the enthalpy of vapour of material being evaporated. Once the entirety of the material has been boiled off, the condensation vessel is drained into the storage vessel. Now the condensation vessel is empty, the boiling vessel's temperature can then be raised more until the next lowest boiling point is reached, thus repeating the process. The process is repeated until the desired material has been completely evaporated from the boiling vessel into condensation vessel. From this point on the desired material is completely isolated and we obtain a hopefully pure sample. The agent can then choose action 5, or done, in order to end the experiment. In lesson 3 in these sets of tutorial for the distillation bench, we will try to get a high reward by obtaining a high molar amount of pure dodecane in our condensation vessel. In this tutorial though, we will go ahead and show you the basic actions that your agent can choose to do. For now, we will manually input the action and the multiplier at each time step, however the whole purpose of these environments is to train the agent with reinforcement learning. Hopefully after finishing these lessons, you will give RL with these agents a go! Let's get started with the different actions! First let's start by adding temperature to the boiling vessel. This can be acheived by setting the action to 0, and making the multiplier an integer higher than 5. Note that a multiplier of 5 will not affect the temperature and any lower will decrease temperature. Notice how the boiling vessel's temperature is now 374.6 Kelvin. The boiling point of H2O as specified in the material.py file is 373.15 K. So we are now exceeding this temperature which allows us to boil off water, in this case 0.276 mol of it. We can see this boiled off H2O in our beaker_0 in the diagrams which you'll notice before was empty. After, this we can test out pouring from the condensation vessel into the storage vessel. We can then see that storage vessel is now filled with the H2O poured from the condensation vessel. Note there is a problem with the diagrams right now that should be fixed. Next, let's increase the temperature one more time, and then test actions 1 and 3. First Let's pour from the condensation vessel to boiling vessel after boiling some more materials. Noticed that we now have boiled 0.17 mols 2-chlorohexane. The graph should no longer have H2O in beaker_1 Let's try pouring everything back to the boiling vessel You should see now that everything from the condensation vessel is back in the boiling vessel. * ---Should insert graph here but it doesn't show the action correctly--- Now let's try pouring everything from the boiling vessel into the condensation vessel. Notice now that all the materials are in the condensation vessel. Next we can test pouring the H2O in the storage vessel into the boiling vessel which is the last action we can select. Now you can see that the H2O which was previously in the storage vessel, is now in the boiling vessel. We can now then tell the agent to stop the experiment using action 5 and multiplier 0. This concludes the end of our tutorial. Hopefully you got a chance to see how the basic actions in the distillation environment works and see how you can use the agent in RL applications to maximize the distillation of a desired material. In the next tutorial we will perform 2 experiments where we heat up the boiling vessel to the maximum temperature it can reach, and vice versa where we cool it to the lowest temperature.","title":"Distillation Bench Tutorial"},{"location":"Tutorial3/#distillation-bench-lesson-1","text":"","title":"Distillation Bench: Lesson 1"},{"location":"Tutorial3/#familiarizing-actions-for-the-distillation-bench","text":"In this tutorial, I will teach you how the distillation environment works. In this distillation we are taking the tests/test_extract_vessel.pickle which is a pickle file generated when we ran the extraction bench. It is important to know that before running the distillation bench, you must first complete both reaction and extraction, in order to follow the workflow our environment. To find out more, take a look at the readme.md file on our github. Start by running /tests/demo_lesson_1d.py and you should see a series of graphs appear: These graphs show the contents of our containers. There are 3 main containers: - boiling vessel - beaker 1 - beaker 2 The boiling vessel contains all the materials at the initial state of the experiment. Beaker 1 can be thought of as a condensation vessel which is connected to the distillation vessel via a tube and this will contain all the materials that are being boiled off. Beaker 2 is then the storage vessel, where the condensation vessel can be emptied, in order to make room for other material. Now after we load in our desired environment, we should be prompted with a message asking us to pick our desired action and the multiplier. Let me explain what this means by taking a look at our action space. Our action space is given by a matrix of shape {0, 1} n_action x multiplier . The agent at each time step essentially picks from a set of actions, and then a multiplier for that given action. The multiplier affects each action differently. For example the way the agents chosen multiplier affects heat change is by the following code: In this case the heat change is affected by both the user's chosen multiplier and the dQ which is an attribute for the maximum change in thermal energy. Typically, an agent will choose actions based on what will give a higher reward, and higher rewards are given by getting a high molar amount of the desired material, in this case, dodecane, as well as a high purity in one particular vessel. From a chemistry point of view, what's happening is that the agent is extracting a material from the boiling vessel, which contains multiple materials, and it does this by utilizing the different material's boiling points. The experiment begins by raising the temperature of the boiling vessel which will allow certain materials in that vessel to boil off into the condensation vessel/beaker 1. The amount of energy required to raise the temperature of the materials in the vessel are dependent on their specific heat properties, which can be found in the chemistrylab/chem_algorithms/material.py file. As more heat is added we will eventually reach the lowest boiling point of the materials in the vessel, and any more heat added will act to evaporate this material. The now gaseous material will rise out of the boiling vessel into the tube that feeds into the condensation vessel where it will condense back into its liquid form. In this virtual experiment it is assumed that this takes place instantaneously. The amount of material evaporated is dependent on the enthalpy of vapour of material being evaporated. Once the entirety of the material has been boiled off, the condensation vessel is drained into the storage vessel. Now the condensation vessel is empty, the boiling vessel's temperature can then be raised more until the next lowest boiling point is reached, thus repeating the process. The process is repeated until the desired material has been completely evaporated from the boiling vessel into condensation vessel. From this point on the desired material is completely isolated and we obtain a hopefully pure sample. The agent can then choose action 5, or done, in order to end the experiment. In lesson 3 in these sets of tutorial for the distillation bench, we will try to get a high reward by obtaining a high molar amount of pure dodecane in our condensation vessel. In this tutorial though, we will go ahead and show you the basic actions that your agent can choose to do. For now, we will manually input the action and the multiplier at each time step, however the whole purpose of these environments is to train the agent with reinforcement learning. Hopefully after finishing these lessons, you will give RL with these agents a go! Let's get started with the different actions! First let's start by adding temperature to the boiling vessel. This can be acheived by setting the action to 0, and making the multiplier an integer higher than 5. Note that a multiplier of 5 will not affect the temperature and any lower will decrease temperature. Notice how the boiling vessel's temperature is now 374.6 Kelvin. The boiling point of H2O as specified in the material.py file is 373.15 K. So we are now exceeding this temperature which allows us to boil off water, in this case 0.276 mol of it. We can see this boiled off H2O in our beaker_0 in the diagrams which you'll notice before was empty. After, this we can test out pouring from the condensation vessel into the storage vessel. We can then see that storage vessel is now filled with the H2O poured from the condensation vessel. Note there is a problem with the diagrams right now that should be fixed. Next, let's increase the temperature one more time, and then test actions 1 and 3. First Let's pour from the condensation vessel to boiling vessel after boiling some more materials. Noticed that we now have boiled 0.17 mols 2-chlorohexane. The graph should no longer have H2O in beaker_1 Let's try pouring everything back to the boiling vessel You should see now that everything from the condensation vessel is back in the boiling vessel. * ---Should insert graph here but it doesn't show the action correctly--- Now let's try pouring everything from the boiling vessel into the condensation vessel. Notice now that all the materials are in the condensation vessel. Next we can test pouring the H2O in the storage vessel into the boiling vessel which is the last action we can select. Now you can see that the H2O which was previously in the storage vessel, is now in the boiling vessel. We can now then tell the agent to stop the experiment using action 5 and multiplier 0. This concludes the end of our tutorial. Hopefully you got a chance to see how the basic actions in the distillation environment works and see how you can use the agent in RL applications to maximize the distillation of a desired material. In the next tutorial we will perform 2 experiments where we heat up the boiling vessel to the maximum temperature it can reach, and vice versa where we cool it to the lowest temperature.","title":"Familiarizing Actions for the Distillation Bench"},{"location":"UsingCmdLine/","text":"Using Command Line","title":"Using Command Line"},{"location":"UsingCmdLine/#using-command-line","text":"","title":"Using Command Line"},{"location":"VisualizingOutput/","text":"Visualizing Output","title":"Visualizing Output"},{"location":"VisualizingOutput/#visualizing-output","text":"","title":"Visualizing Output"},{"location":"WhatIsChemGymRL/","text":"What is ChemGymRL?","title":"What is ChemGymRL?"},{"location":"WhatIsChemGymRL/#what-is-chemgymrl","text":"","title":"What is ChemGymRL?"},{"location":"custom_extraction_lesson/","text":"Building A Custom Extraction File For this tutorial we will be showing you how to create a custom extraction environment to train an RL agent on! In this case we will be doing the extraction of Methyl Red from a solution of hydrochloric acid into Ethyl Acetate. The procedure and set up of this reaction can be found at this link . Now let's get started. The extraction bench is one of the more complicated environments to build since there are a lot more actions to take in the environment and as a result a lot more to set up. As a result we are starting with a very simple, single extraction but after having implemented this it should be obvious how to extend this to larger more complicated extractions. Typically, in a new reaction or extraction it will be important to define the new materials in chemistrylab/chem_algorithms/material.py but for this case we have implemented the 2 new materials (methyl red and ethyl acetate). Go into the material file and look at the materials and familiarize yourself with the properties of each material. In your own project after creating the new materials it is then time to create the extraction environment space, and the actions that can be performed in that extraction. For a simple single extraction we can use a prebuilt environment in this case chemistrylab/extract_bench/extraction_0.py . Please take a read through the file and try to understand how actions are performed and how we set up vessels. Now we will create a new extraction bench file in the following directory chemistrylab/extract_bench , let's create a new file called methyl_red.py . In this new file we are going to use the following code: import numpy as np import gym import gym.spaces from chemistrylab.extract_bench.extract_bench_v1_engine import ExtractBenchEnv from chemistrylab.chem_algorithms import material, util, vessel # initialize extraction vessel extraction_vessel = vessel.Vessel(label='extraction_vessel', ) # initialize materials H2O = material.H2O HCl = material.HCl H = material.H Cl = material.Cl MethylRed = material.MethylRed EthylAcetate = material.EthylAcetate # material_dict # The material dict is the data-structure we use to describe the materials that will be in our vessel # found inside of our vessel, in this case it is of the form # {material_name: [material_class, quantity, unit]} # you don't need to specify a unit but if you don't we assume you are using mols material_dict = {H2O().get_name(): [H2O, 27.7], H().get_name(): [H, 2.5e-4], Cl().get_name(): [Cl, 2.5e-4], MethylRed().get_name(): [MethylRed, 9.28e-4], } # solute_dict # the solute dict describes how different materials are dissolved in others # {solute_name: {solvent_name: [quantity, unit]}} # you don't need to specify a unit but if you don't we assume you are using mols solute_dict = {H().get_name(): {H2O().get_name(): [27.7, 'mol']}, Cl().get_name(): {H2O().get_name(): [27.7, 'mol']}, MethylRed().get_name(): {H2O().get_name(): [500, 'ml']}, } # this function checks if we have poured too many materials in our vessel and if we have it returns a vessel # with the appropriate amount of materials lost material_dict, solute_dict, _ = util.check_overflow(material_dict=material_dict, solute_dict=solute_dict, v_max=extraction_vessel.get_max_volume(), ) # Here we push events that update the material dictionary, solute dictionary and then mix all of the materials together event_1 = ['update material dict', material_dict] event_2 = ['update solute dict', solute_dict] event_3 = ['fully mix'] extraction_vessel.push_event_to_queue(events=None, feedback=[event_1], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_2], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_3], dt=0) # Here is our initialization of the extraction bench environment # Make sure to give it a unique name and specify the correct extraction bench that we have defined above # in this case our extractor is EthylAcetate because it is less polar than water, this in turn allows us # to extract the desired material methyl red class ExtractWorld_MethylRed(ExtractBenchEnv): def __init__(self): super(ExtractWorld_MethylRed, self).__init__( extraction='extraction_0', extraction_vessel=extraction_vessel, target_material='methyl red', extractor=EthylAcetate ) Now we just have to add some code to allow the new environment to be recognized by gym. In the following file chemistrylab/__init__.py we will add the following line of code: register( id='MethylRed_Extract-v1', entry_point='chemistrylab.extract_bench.methyl_red:ExtractWorld_MethylRed', max_episode_steps=100 ) Now we're done! To test that these changes have worked, simply run the following code: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Extract' in env_spec.id] print(env_ids) You should see in the output MethylRed_Extract-v1 # ['WurtzExtract-v1', 'Oil_Water_Extract-v1', 'MethylRed_Extract-v1', 'MethylRed_Extract-v2']","title":"Custom Extraction Lesson"},{"location":"custom_extraction_lesson/#building-a-custom-extraction-file","text":"For this tutorial we will be showing you how to create a custom extraction environment to train an RL agent on! In this case we will be doing the extraction of Methyl Red from a solution of hydrochloric acid into Ethyl Acetate. The procedure and set up of this reaction can be found at this link . Now let's get started. The extraction bench is one of the more complicated environments to build since there are a lot more actions to take in the environment and as a result a lot more to set up. As a result we are starting with a very simple, single extraction but after having implemented this it should be obvious how to extend this to larger more complicated extractions. Typically, in a new reaction or extraction it will be important to define the new materials in chemistrylab/chem_algorithms/material.py but for this case we have implemented the 2 new materials (methyl red and ethyl acetate). Go into the material file and look at the materials and familiarize yourself with the properties of each material. In your own project after creating the new materials it is then time to create the extraction environment space, and the actions that can be performed in that extraction. For a simple single extraction we can use a prebuilt environment in this case chemistrylab/extract_bench/extraction_0.py . Please take a read through the file and try to understand how actions are performed and how we set up vessels. Now we will create a new extraction bench file in the following directory chemistrylab/extract_bench , let's create a new file called methyl_red.py . In this new file we are going to use the following code: import numpy as np import gym import gym.spaces from chemistrylab.extract_bench.extract_bench_v1_engine import ExtractBenchEnv from chemistrylab.chem_algorithms import material, util, vessel # initialize extraction vessel extraction_vessel = vessel.Vessel(label='extraction_vessel', ) # initialize materials H2O = material.H2O HCl = material.HCl H = material.H Cl = material.Cl MethylRed = material.MethylRed EthylAcetate = material.EthylAcetate # material_dict # The material dict is the data-structure we use to describe the materials that will be in our vessel # found inside of our vessel, in this case it is of the form # {material_name: [material_class, quantity, unit]} # you don't need to specify a unit but if you don't we assume you are using mols material_dict = {H2O().get_name(): [H2O, 27.7], H().get_name(): [H, 2.5e-4], Cl().get_name(): [Cl, 2.5e-4], MethylRed().get_name(): [MethylRed, 9.28e-4], } # solute_dict # the solute dict describes how different materials are dissolved in others # {solute_name: {solvent_name: [quantity, unit]}} # you don't need to specify a unit but if you don't we assume you are using mols solute_dict = {H().get_name(): {H2O().get_name(): [27.7, 'mol']}, Cl().get_name(): {H2O().get_name(): [27.7, 'mol']}, MethylRed().get_name(): {H2O().get_name(): [500, 'ml']}, } # this function checks if we have poured too many materials in our vessel and if we have it returns a vessel # with the appropriate amount of materials lost material_dict, solute_dict, _ = util.check_overflow(material_dict=material_dict, solute_dict=solute_dict, v_max=extraction_vessel.get_max_volume(), ) # Here we push events that update the material dictionary, solute dictionary and then mix all of the materials together event_1 = ['update material dict', material_dict] event_2 = ['update solute dict', solute_dict] event_3 = ['fully mix'] extraction_vessel.push_event_to_queue(events=None, feedback=[event_1], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_2], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_3], dt=0) # Here is our initialization of the extraction bench environment # Make sure to give it a unique name and specify the correct extraction bench that we have defined above # in this case our extractor is EthylAcetate because it is less polar than water, this in turn allows us # to extract the desired material methyl red class ExtractWorld_MethylRed(ExtractBenchEnv): def __init__(self): super(ExtractWorld_MethylRed, self).__init__( extraction='extraction_0', extraction_vessel=extraction_vessel, target_material='methyl red', extractor=EthylAcetate ) Now we just have to add some code to allow the new environment to be recognized by gym. In the following file chemistrylab/__init__.py we will add the following line of code: register( id='MethylRed_Extract-v1', entry_point='chemistrylab.extract_bench.methyl_red:ExtractWorld_MethylRed', max_episode_steps=100 ) Now we're done! To test that these changes have worked, simply run the following code: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Extract' in env_spec.id] print(env_ids) You should see in the output MethylRed_Extract-v1 # ['WurtzExtract-v1', 'Oil_Water_Extract-v1', 'MethylRed_Extract-v1', 'MethylRed_Extract-v2']","title":"Building A Custom Extraction File"},{"location":"custom_reaction_lesson/","text":"Building A Custom Reaction File For this tutorial we are going to be creating a very simple reaction NaCl aq -> Na + aq + Cl - aq In order to start with creating an environment for this reaction we first have to create a reaction file which simulates the mechanics of this decomposition. In the directory chemistrylab/reactions you will find a list of reactions that looks something like this: For this case we will create a new reaction file from the reaction template file template_reaction.py , and let's name it decomp_reaction.py . The first change we have to make is to the list of reactants, products and solutes located at line 42 # names of the reactants and products in all reactions # a list of the names of all reactants that are to be used in a reaction REACTANTS = [] # a list of all the names of the reactants that are going to be produced by the reaction PRODUCTS = [] ALL_MATERIALS = REACTANTS + PRODUCTS # specify the solute in which the reaction is meant to take place in SOLUTES = [] we change the above to the following: REACTANTS = ['NaCl'] PRODUCTS = ['Na', 'Cl'] ALL_MATERIALS = REACTANTS + PRODUCTS SOLUTES = ['H2O'] In this case we are letting the reaction file know what reagents we are using and the desired product so that we can easily track and display their concentrations. Next up we have to look at our spectra parameters. The specification of which exact spectra variables we use is not important, but it is important to have the right number of spectra so we can generate absorbance data. The following line of code is located at line 126 in the initialization function of the Reaction class if overlap: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) else: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) We change the above to look like: if overlap: self.params.append(spec.S_3_3) # spectra for NaCl self.params.append(spec.S_6) # spectra for the Na self.params.append(spec.S_7) # spectra for the Cl else: self.params.append(spec.S_8) # spectra for NaCl self.params.append(spec.S_1) # spectra for the Na self.params.append(spec.S_3) # spectra for the Cl A note on the spectra that the numbers have no significance, so feel free to pick any spectra you wish. Now that we have our spectra corrected we now have to change the update function of our file. For these reactions we use an ODE solver to calculate the change in concentration over time. As such we have to change some parameters on how we update the rates of reaction. # obtain the concentration (all concentrations are in mol/m**3) C = self.get_concentration(V) # define a space to contain the changes in concentration to each chemical dC = np.zeros(self.n.shape[0]) # define the reaction constant for each reaction k1 = A1 * np.exp((-1 * E1)/(R * T)) # define the rate of each reaction self.rate[0] = k1 * C[0] * dt # calculate and store the changes in concentration of each chemical dC[0] = (-1.0 * self.rate[0]) dC[1] = (1.0 * self.rate[0]) dc[2] = (1.0 * self.rate[0]) In this case we don't need to update these parameters but depending on the number of simultaneous reactions and the rates and how they relate to the concentration of a substance there will need to be additional parameters added, this can be seen in wurtz_reaction.py : # set the pre-exponential constant using the above scaling factor for proper dimensionality A0 = 1.0 / scaling_factor # Reaction 0 A1 = 1.0 / scaling_factor # Reaction 1 A2 = 1.0 / scaling_factor # Reaction 2 A3 = 1.0 / scaling_factor # Reaction 3 A4 = 1.0 / scaling_factor # Reaction 4 A5 = 1.0 / scaling_factor # Reaction 5 # set the activation energies for each reaction constant E0 = 1.0 E1 = 1.0 E2 = 1.0 E3 = 1.0 E4 = 1.0 E5 = 1.0 # define the reaction constant for each reaction; k0 = A0 * np.exp((-1 * E0)/(R * T)) k1 = A1 * np.exp((-1 * E1)/(R * T)) k2 = A2 * np.exp((-1 * E2)/(R * T)) k3 = A3 * np.exp((-1 * E3)/(R * T)) k4 = A4 * np.exp((-1 * E4)/(R * T)) k5 = A5 * np.exp((-1 * E5)/(R * T)) # define the rate of each reaction; # note the reactants in the concentration array (C) are in # the order of the reactants in the `REACTANTS` variable; # using the stoichiometric ratio in the rate exponentials gives the following rates: self.rate[0] = k0 * (C[0] ** 2) * (C[1] ** 0) * (C[2] ** 0) * (C[3] ** 1) self.rate[1] = k1 * (C[0] ** 1) * (C[1] ** 1) * (C[2] ** 0) * (C[3] ** 1) self.rate[2] = k2 * (C[0] ** 1) * (C[1] ** 0) * (C[2] ** 1) * (C[3] ** 1) self.rate[3] = k3 * (C[0] ** 0) * (C[1] ** 2) * (C[2] ** 0) * (C[3] ** 1) self.rate[4] = k4 * (C[0] ** 0) * (C[1] ** 1) * (C[2] ** 1) * (C[3] ** 1) self.rate[5] = k5 * (C[0] ** 0) * (C[1] ** 0) * (C[2] ** 2) * (C[3] ** 1) # calculate and store the changes in concentration of each chemical; # recall: change in concentration = molar concentration * rate * dt # ie. for A + 2B --> C and A + C --> D as parallel reactions # change in A = (-1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in B = (-2 * rate of reaction 1 * dt) # change in C = (+1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in D = (+1 * rate of reaction 2 * dt) # assuming both reactions have the same time-step, which is true for all reactions in this file dC[0] = (-2.0 * self.rate[0]) + (-1.0 * self.rate[1]) + (-1.0 * self.rate[2]) * dt # change in 1-chlorohexane dC[1] = (-1.0 * self.rate[1]) + (-2.0 * self.rate[3]) + (-1.0 * self.rate[4]) * dt # change in 2-chlorohexane dC[2] = (-2.0 * self.rate[2]) + (-1.0 * self.rate[4]) + (-2.0 * self.rate[5]) * dt # change in 3-chlorohexane dC[3] = -2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in Na dC[4] = 1.0 * self.rate[0] * dt # change in dodecane dC[5] = 1.0 * self.rate[1] * dt # change in 5-methylundecane dC[6] = 1.0 * self.rate[2] * dt # change in 4-ethyldecane dC[7] = 1.0 * self.rate[3] * dt # change in 5,6-dimethyldecane dC[8] = 1.0 * self.rate[4] * dt # change in 4-ethyl-5-methylnonane dC[9] = 1.0 * self.rate[5] * dt # change in 4,5-diethyloctane dC[10] = 2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in NaCl As far as the reaction file, it is now set up and ready to go. Now inorder to use the reaction we need to make a simple change to the reaction bench engine located chemistrylab/reaction_bench/reaction_bench_v0_engine.py in this case you should duplicate this file and rename the file reaction_bench_v0_engine_decomp at the top of the file you should see a line like the one below where we import the reaction that the engine will use: from chemistrylab.reactions.wurtz_reaction import Reaction We will change the import so that we import the new reaction we just created from chemistrylab.reactions.decomp_reaction import Reaction It will also be easier for us to change the name of the engine class from: ReactionBenchEnv to ReactionBenchEnvDecomp We are now onto the last 2 additions that will allow us to use this reaction environment. In this file chemistrylab/reaction_bench/reaction_bench_v0.py we are going to add some code that will allow us to initialize our new reaction environment so that we can then register it and use it. At the bottom of this file we will add the following lines of code: class ReactionBenchEnv_1(ReactionBenchEnvDecomp): def __init__(self): super(ReactionBenchEnv_1, self).__init__( materials=[ {\"Material\": \"NaCl\", \"Initial\": 1}, ], solutes=[ {\"Solute\": \"H2O\", \"Initial\": 1} ], desired=\"Na\", overlap=False ) This code simply sets up the environement we will be using. So in this case we establish the materials that the reaction will use and the initial quantity of that substance in mols. We then also establish our solute, in this case, 1 mol of water. Lastly we specify our desired material so that we can calculate the reward which the RL agent will recieve. This takes us to the final step which is registering the environment with gym. In this file: chemistrylab/__init__.py we are going to add a few more lines of code. register( id='DecompReactLesson-v0', entry_point='chemistrylab.reaction_bench.reaction_bench_v0:ReactionBenchEnv_1', max_episode_steps=20 ) This code simply tells gym where to find our new environment. Now we're done if you run the following code you should now be able to see our new environment: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'React' in env_spec.id] print(env_ids) #['WurtzReact-v0', 'WurtzReact_overlap-v0', 'DecompReactLesson-v0'] Here we can clearly see that our environment has been added!","title":"Custom Reaction Lesson"},{"location":"custom_reaction_lesson/#building-a-custom-reaction-file","text":"For this tutorial we are going to be creating a very simple reaction NaCl aq -> Na + aq + Cl - aq In order to start with creating an environment for this reaction we first have to create a reaction file which simulates the mechanics of this decomposition. In the directory chemistrylab/reactions you will find a list of reactions that looks something like this: For this case we will create a new reaction file from the reaction template file template_reaction.py , and let's name it decomp_reaction.py . The first change we have to make is to the list of reactants, products and solutes located at line 42 # names of the reactants and products in all reactions # a list of the names of all reactants that are to be used in a reaction REACTANTS = [] # a list of all the names of the reactants that are going to be produced by the reaction PRODUCTS = [] ALL_MATERIALS = REACTANTS + PRODUCTS # specify the solute in which the reaction is meant to take place in SOLUTES = [] we change the above to the following: REACTANTS = ['NaCl'] PRODUCTS = ['Na', 'Cl'] ALL_MATERIALS = REACTANTS + PRODUCTS SOLUTES = ['H2O'] In this case we are letting the reaction file know what reagents we are using and the desired product so that we can easily track and display their concentrations. Next up we have to look at our spectra parameters. The specification of which exact spectra variables we use is not important, but it is important to have the right number of spectra so we can generate absorbance data. The following line of code is located at line 126 in the initialization function of the Reaction class if overlap: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) else: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) We change the above to look like: if overlap: self.params.append(spec.S_3_3) # spectra for NaCl self.params.append(spec.S_6) # spectra for the Na self.params.append(spec.S_7) # spectra for the Cl else: self.params.append(spec.S_8) # spectra for NaCl self.params.append(spec.S_1) # spectra for the Na self.params.append(spec.S_3) # spectra for the Cl A note on the spectra that the numbers have no significance, so feel free to pick any spectra you wish. Now that we have our spectra corrected we now have to change the update function of our file. For these reactions we use an ODE solver to calculate the change in concentration over time. As such we have to change some parameters on how we update the rates of reaction. # obtain the concentration (all concentrations are in mol/m**3) C = self.get_concentration(V) # define a space to contain the changes in concentration to each chemical dC = np.zeros(self.n.shape[0]) # define the reaction constant for each reaction k1 = A1 * np.exp((-1 * E1)/(R * T)) # define the rate of each reaction self.rate[0] = k1 * C[0] * dt # calculate and store the changes in concentration of each chemical dC[0] = (-1.0 * self.rate[0]) dC[1] = (1.0 * self.rate[0]) dc[2] = (1.0 * self.rate[0]) In this case we don't need to update these parameters but depending on the number of simultaneous reactions and the rates and how they relate to the concentration of a substance there will need to be additional parameters added, this can be seen in wurtz_reaction.py : # set the pre-exponential constant using the above scaling factor for proper dimensionality A0 = 1.0 / scaling_factor # Reaction 0 A1 = 1.0 / scaling_factor # Reaction 1 A2 = 1.0 / scaling_factor # Reaction 2 A3 = 1.0 / scaling_factor # Reaction 3 A4 = 1.0 / scaling_factor # Reaction 4 A5 = 1.0 / scaling_factor # Reaction 5 # set the activation energies for each reaction constant E0 = 1.0 E1 = 1.0 E2 = 1.0 E3 = 1.0 E4 = 1.0 E5 = 1.0 # define the reaction constant for each reaction; k0 = A0 * np.exp((-1 * E0)/(R * T)) k1 = A1 * np.exp((-1 * E1)/(R * T)) k2 = A2 * np.exp((-1 * E2)/(R * T)) k3 = A3 * np.exp((-1 * E3)/(R * T)) k4 = A4 * np.exp((-1 * E4)/(R * T)) k5 = A5 * np.exp((-1 * E5)/(R * T)) # define the rate of each reaction; # note the reactants in the concentration array (C) are in # the order of the reactants in the `REACTANTS` variable; # using the stoichiometric ratio in the rate exponentials gives the following rates: self.rate[0] = k0 * (C[0] ** 2) * (C[1] ** 0) * (C[2] ** 0) * (C[3] ** 1) self.rate[1] = k1 * (C[0] ** 1) * (C[1] ** 1) * (C[2] ** 0) * (C[3] ** 1) self.rate[2] = k2 * (C[0] ** 1) * (C[1] ** 0) * (C[2] ** 1) * (C[3] ** 1) self.rate[3] = k3 * (C[0] ** 0) * (C[1] ** 2) * (C[2] ** 0) * (C[3] ** 1) self.rate[4] = k4 * (C[0] ** 0) * (C[1] ** 1) * (C[2] ** 1) * (C[3] ** 1) self.rate[5] = k5 * (C[0] ** 0) * (C[1] ** 0) * (C[2] ** 2) * (C[3] ** 1) # calculate and store the changes in concentration of each chemical; # recall: change in concentration = molar concentration * rate * dt # ie. for A + 2B --> C and A + C --> D as parallel reactions # change in A = (-1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in B = (-2 * rate of reaction 1 * dt) # change in C = (+1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in D = (+1 * rate of reaction 2 * dt) # assuming both reactions have the same time-step, which is true for all reactions in this file dC[0] = (-2.0 * self.rate[0]) + (-1.0 * self.rate[1]) + (-1.0 * self.rate[2]) * dt # change in 1-chlorohexane dC[1] = (-1.0 * self.rate[1]) + (-2.0 * self.rate[3]) + (-1.0 * self.rate[4]) * dt # change in 2-chlorohexane dC[2] = (-2.0 * self.rate[2]) + (-1.0 * self.rate[4]) + (-2.0 * self.rate[5]) * dt # change in 3-chlorohexane dC[3] = -2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in Na dC[4] = 1.0 * self.rate[0] * dt # change in dodecane dC[5] = 1.0 * self.rate[1] * dt # change in 5-methylundecane dC[6] = 1.0 * self.rate[2] * dt # change in 4-ethyldecane dC[7] = 1.0 * self.rate[3] * dt # change in 5,6-dimethyldecane dC[8] = 1.0 * self.rate[4] * dt # change in 4-ethyl-5-methylnonane dC[9] = 1.0 * self.rate[5] * dt # change in 4,5-diethyloctane dC[10] = 2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in NaCl As far as the reaction file, it is now set up and ready to go. Now inorder to use the reaction we need to make a simple change to the reaction bench engine located chemistrylab/reaction_bench/reaction_bench_v0_engine.py in this case you should duplicate this file and rename the file reaction_bench_v0_engine_decomp at the top of the file you should see a line like the one below where we import the reaction that the engine will use: from chemistrylab.reactions.wurtz_reaction import Reaction We will change the import so that we import the new reaction we just created from chemistrylab.reactions.decomp_reaction import Reaction It will also be easier for us to change the name of the engine class from: ReactionBenchEnv to ReactionBenchEnvDecomp We are now onto the last 2 additions that will allow us to use this reaction environment. In this file chemistrylab/reaction_bench/reaction_bench_v0.py we are going to add some code that will allow us to initialize our new reaction environment so that we can then register it and use it. At the bottom of this file we will add the following lines of code: class ReactionBenchEnv_1(ReactionBenchEnvDecomp): def __init__(self): super(ReactionBenchEnv_1, self).__init__( materials=[ {\"Material\": \"NaCl\", \"Initial\": 1}, ], solutes=[ {\"Solute\": \"H2O\", \"Initial\": 1} ], desired=\"Na\", overlap=False ) This code simply sets up the environement we will be using. So in this case we establish the materials that the reaction will use and the initial quantity of that substance in mols. We then also establish our solute, in this case, 1 mol of water. Lastly we specify our desired material so that we can calculate the reward which the RL agent will recieve. This takes us to the final step which is registering the environment with gym. In this file: chemistrylab/__init__.py we are going to add a few more lines of code. register( id='DecompReactLesson-v0', entry_point='chemistrylab.reaction_bench.reaction_bench_v0:ReactionBenchEnv_1', max_episode_steps=20 ) This code simply tells gym where to find our new environment. Now we're done if you run the following code you should now be able to see our new environment: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'React' in env_spec.id] print(env_ids) #['WurtzReact-v0', 'WurtzReact_overlap-v0', 'DecompReactLesson-v0'] Here we can clearly see that our environment has been added!","title":"Building A Custom Reaction File"},{"location":"input/","text":"Input","title":"Input"},{"location":"input/#input","text":"","title":"Input"},{"location":"jenkins/","text":"Jenkins: Pipelinefile Below here is the file that you must add to your branch, however there are a few changes that must be made for your branch. Create a file named Jenkinsfile at the root of the repository so in our case chemistrygym/Jenkinsfile and copy the text below into the file. Please then make the appropriate changes highlighted by the comments. This file tells jenkins what to buildand as such you must include the file inorder for our tests to run. pipeline { agent any stages { stage('Cleanup Workspace') { steps { cleanWs() sh \"\"\" echo \"Cleaned Up Workspace For Project\" \"\"\" } } stage('pull git'){ steps { // !!!!!! Change branch name below to match the branch you are working in !!!!!! git branch: 'YOUR_BRANCH_HERE', credentialsId: '1de24870-cdba-4190-a8fb-f0508d298280', url: 'https://github.com/CLEANit/chemistrygym.git' } } stage('set up venv and install dependencies'){ steps { sh 'python -m venv test_env' sh 'ls test_env' sh 'ls test_env/bin' sh '. ./test_env/bin/activate' sh 'pip3 install -r requirements.txt' } } stage(' Unit Testing Reaction') { steps { sh 'cd tests/unit/reaction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } stage(' Unit Testing Extraction') { steps { sh 'cd ../tests/unit/extraction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } // if you have another unit test directory that is not being run in the build you may use the sample code below to test it /* stage('Unit Testing TEST FILE') { steps { sh 'cd ../tests/unit/TEST_DIRECTORY' sh 'python3 -m unittest discover -p \"*_test.py\"' } } */ } }","title":"Using Jenkins"},{"location":"jenkins/#jenkins-pipelinefile","text":"Below here is the file that you must add to your branch, however there are a few changes that must be made for your branch. Create a file named Jenkinsfile at the root of the repository so in our case chemistrygym/Jenkinsfile and copy the text below into the file. Please then make the appropriate changes highlighted by the comments. This file tells jenkins what to buildand as such you must include the file inorder for our tests to run. pipeline { agent any stages { stage('Cleanup Workspace') { steps { cleanWs() sh \"\"\" echo \"Cleaned Up Workspace For Project\" \"\"\" } } stage('pull git'){ steps { // !!!!!! Change branch name below to match the branch you are working in !!!!!! git branch: 'YOUR_BRANCH_HERE', credentialsId: '1de24870-cdba-4190-a8fb-f0508d298280', url: 'https://github.com/CLEANit/chemistrygym.git' } } stage('set up venv and install dependencies'){ steps { sh 'python -m venv test_env' sh 'ls test_env' sh 'ls test_env/bin' sh '. ./test_env/bin/activate' sh 'pip3 install -r requirements.txt' } } stage(' Unit Testing Reaction') { steps { sh 'cd tests/unit/reaction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } stage(' Unit Testing Extraction') { steps { sh 'cd ../tests/unit/extraction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } // if you have another unit test directory that is not being run in the build you may use the sample code below to test it /* stage('Unit Testing TEST FILE') { steps { sh 'cd ../tests/unit/TEST_DIRECTORY' sh 'python3 -m unittest discover -p \"*_test.py\"' } } */ } }","title":"Jenkins: Pipelinefile"},{"location":"lesson_1_extract/","text":"Extraction Bench: Lesson 1 Using a non-polar solute to extract a solute from water In this tutorial, we am going to walk you through how our environment works and hopefully give some insight into how an RL agent might interact with the envirionment. In this extraction we are going to be using oil to extract sodium and chlorine from water. We are going to be using this file lessons/extraction_bench/oil_water.py in order to interact with the environment and to try and achieve a high reward! So start by running the lessons/extraction_bench/oil_water.py you should see a series of graphs like these appear: These graphs show the contents of each of our containers and the level of seperation between the materials. The graphs to the right then show the layers of materials forming in the container. When we start the environment we will see that we have a container filled with water, Na and Cl. The objective of this environment is to get the Na out of the water, but how might we do this? As the chemists amoung us will say this is a very simple task, and indeed it is. Using a non-polar solvent we can get the sodium and chlorine to diffuse from the water into that solvent, in this case we can use oil as our non-polar solvent! so now that the environemnt is loaded, you should see a prompt in the command line. Before we start playing around with the environment, let's take a look at the action space. For this case our action space is a matrix: {0, 1} n_action x multiplier in essence at each time step the RL agent selects from a set of actions and then in turn picks a multiplier for that action. Action: Multiplier 0: Multiplier 1: Multiplier 2: Multiplier 3: Mix beaker 1 0 1 0 0 Drain beaker 1 into 2 0 0 0 0 Pour oil into beaker 1 0 0 0 0 As an example the agent might want to pour a certain amount of solution out of our container so the row controls what action they take, and the column represents an action multiplier. So in the example of pouring out a certain amount of solution, the multiplier might control how much of the solution we pour out of our container. so our action matrix will thus be a matrix of zeroes with a single 1. In the set up of the environment we select a dT, this dT represents the period of time we take in between each action. Now that we have a better idea of our action space we can move onto testing out the environment. As stated earlier we need to use oil to extract the sodium from the water, but if we look at the graph now, we can clearly see that there is no oil in the container, so let's add some! Now that we've added the oil we need to mix the vessel to get the sodium to transfer into the oil, so let's mix the vessel! Now that we have done some mixing we need to wait for the oil to settle to the top of the water so we can drain the water. Keep repeating the following command until the graph settles. Now that the water and oil have settled we want to drain out our water into beaker 1 so that we can pour out our oil into vessel 2. Keep repeating the command the changing the multiplier as needed until the graph looks something like this: Now we pour the oil into vessel 2. Now if we want to we can pour back the water from vessel 1 into our extraction vessel and repeat the process to get a more of the sodium out of the oil. However, for an introduction this much should satisfy, now that we have finished, we want to see how well we did so now we enter the done command. We hope this tutorial helped with your understanding of how an agent might interact with the extraction environmenment!","title":"Extraction Bench Tutorial"},{"location":"lesson_1_extract/#extraction-bench-lesson-1","text":"","title":"Extraction Bench: Lesson 1"},{"location":"lesson_1_extract/#using-a-non-polar-solute-to-extract-a-solute-from-water","text":"In this tutorial, we am going to walk you through how our environment works and hopefully give some insight into how an RL agent might interact with the envirionment. In this extraction we are going to be using oil to extract sodium and chlorine from water. We are going to be using this file lessons/extraction_bench/oil_water.py in order to interact with the environment and to try and achieve a high reward! So start by running the lessons/extraction_bench/oil_water.py you should see a series of graphs like these appear: These graphs show the contents of each of our containers and the level of seperation between the materials. The graphs to the right then show the layers of materials forming in the container. When we start the environment we will see that we have a container filled with water, Na and Cl. The objective of this environment is to get the Na out of the water, but how might we do this? As the chemists amoung us will say this is a very simple task, and indeed it is. Using a non-polar solvent we can get the sodium and chlorine to diffuse from the water into that solvent, in this case we can use oil as our non-polar solvent! so now that the environemnt is loaded, you should see a prompt in the command line. Before we start playing around with the environment, let's take a look at the action space. For this case our action space is a matrix: {0, 1} n_action x multiplier in essence at each time step the RL agent selects from a set of actions and then in turn picks a multiplier for that action. Action: Multiplier 0: Multiplier 1: Multiplier 2: Multiplier 3: Mix beaker 1 0 1 0 0 Drain beaker 1 into 2 0 0 0 0 Pour oil into beaker 1 0 0 0 0 As an example the agent might want to pour a certain amount of solution out of our container so the row controls what action they take, and the column represents an action multiplier. So in the example of pouring out a certain amount of solution, the multiplier might control how much of the solution we pour out of our container. so our action matrix will thus be a matrix of zeroes with a single 1. In the set up of the environment we select a dT, this dT represents the period of time we take in between each action. Now that we have a better idea of our action space we can move onto testing out the environment. As stated earlier we need to use oil to extract the sodium from the water, but if we look at the graph now, we can clearly see that there is no oil in the container, so let's add some! Now that we've added the oil we need to mix the vessel to get the sodium to transfer into the oil, so let's mix the vessel! Now that we have done some mixing we need to wait for the oil to settle to the top of the water so we can drain the water. Keep repeating the following command until the graph settles. Now that the water and oil have settled we want to drain out our water into beaker 1 so that we can pour out our oil into vessel 2. Keep repeating the command the changing the multiplier as needed until the graph looks something like this: Now we pour the oil into vessel 2. Now if we want to we can pour back the water from vessel 1 into our extraction vessel and repeat the process to get a more of the sodium out of the oil. However, for an introduction this much should satisfy, now that we have finished, we want to see how well we did so now we enter the done command. We hope this tutorial helped with your understanding of how an agent might interact with the extraction environmenment!","title":"Using a non-polar solute to extract a solute from water"},{"location":"lesson_1_react/","text":"Reaction Bench: Lesson 1 Part 1: In this lesson I will be taking you through how our reaction bench environment works and how an RL agent might interact with the environment. The reaction bench environment is meant to as it sounds simulate a reaction, in most reaction benches the agent will have a number of reagents and the ability to play with the environmental conditions of the reaction and through doing this the agent is trying to maximize the yield of a certain desired material. For the reaction bench we use a reaction file which specifies the mechanics of a certain reaction or multiple reactions. For instance the Wurtz reaction is made up of 6 different reactions and as such is a very complicated reaction which the agent has to try and learn the mechanisms of the reaction environment it is in. For this lesson we will be using a simplified version of the wurtz reaction to introduce you to how actions affect the environment. Firtst let's load up the environment, I highly recommend you look at the source code for the reaction bench and reaction, it should help provide insight into how this all works. Further the lesson on creating a custom reaction environment will also help give insight into the reaction mechanics. In order to run the environment simply run: lessons/reaction_bench/reaction_wurtz.py . When you run this file you should see a prompt like this in your command line along with the following graph: Understanding the graph above is important to understanding how the agent will have to understand the environment. On the left we can see the absorbance spectra of the materials in our reaction vessel, and on the right we have a relative scale of a number of important metrics. From left to right we have time passed, temperature, volume (solvent) , presure, and the quantity of reagents that we have available to use. All of this data is what the RL agent has inorder for it to try and optimize the reaction pathway. The reaction we are using is as follows: 2 1-chlorohexane + 2 Na --> dodecane + 2 NaCl This reaction is performed in an aqueous state with ethoxyethane as the solvent. With all that out of the way let's focus our attention to the action space. For this reaction environemnt our action space is represented by a 6 element vector. Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na Value range: 0-1 0-1 0-1 0-1 0-1 0-1 As you might have noticed now, the reaction bench environment deals with a continuous action space. So what exactly do these continuous values represent? For the environmental conditions, in this case Volume and Temperature 0 represents a decrease in temperature or volume by dT or dV (specified in the reaction bench), 1/2 represents no change, and 1 represents an increase by dT or dV. For the chemicals, 0 represents adding no amount of that chemical to the reaction vessel, and 1 represents adding all of the originally available chemical (there is a negative reward if you try to add more chemical than is available). Now that we understand the action space I encourage you to use this reaction environment and to play around with the environmental conditions and adding the chemicals into the reaction vessel. Part 2: Here I will provide instructions on how to maximize the return of this reaction environment. This is fairly simple for this task and have thus provided some script which demonstrates our strategy, and I encourage you to try your own strategy and see how it performs. In this case cour strategy is at step 1 to increase the temperature, keep the volume of solvent constant, and to add all our reagents, in this case 1-chlorohexane and Na. This gives us an action vector of: Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 1 0 0 1 Then at every next step we are going to keep the solvent volume constant and increase the temperature Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 0 0 0 0 to see this strategy in action simply run lessons/reaction_bench/reaction_wurtz_automated.py you should see a graph like this at the end and recieve a reward of the following: and now we're done! I hope you have a better sense of how the reaction environment works and the process through which an RL agent must go through to learn the environment.","title":"Reaction Bench Tutorial"},{"location":"lesson_1_react/#reaction-bench-lesson-1","text":"","title":"Reaction Bench: Lesson 1"},{"location":"lesson_1_react/#part-1","text":"In this lesson I will be taking you through how our reaction bench environment works and how an RL agent might interact with the environment. The reaction bench environment is meant to as it sounds simulate a reaction, in most reaction benches the agent will have a number of reagents and the ability to play with the environmental conditions of the reaction and through doing this the agent is trying to maximize the yield of a certain desired material. For the reaction bench we use a reaction file which specifies the mechanics of a certain reaction or multiple reactions. For instance the Wurtz reaction is made up of 6 different reactions and as such is a very complicated reaction which the agent has to try and learn the mechanisms of the reaction environment it is in. For this lesson we will be using a simplified version of the wurtz reaction to introduce you to how actions affect the environment. Firtst let's load up the environment, I highly recommend you look at the source code for the reaction bench and reaction, it should help provide insight into how this all works. Further the lesson on creating a custom reaction environment will also help give insight into the reaction mechanics. In order to run the environment simply run: lessons/reaction_bench/reaction_wurtz.py . When you run this file you should see a prompt like this in your command line along with the following graph: Understanding the graph above is important to understanding how the agent will have to understand the environment. On the left we can see the absorbance spectra of the materials in our reaction vessel, and on the right we have a relative scale of a number of important metrics. From left to right we have time passed, temperature, volume (solvent) , presure, and the quantity of reagents that we have available to use. All of this data is what the RL agent has inorder for it to try and optimize the reaction pathway. The reaction we are using is as follows: 2 1-chlorohexane + 2 Na --> dodecane + 2 NaCl This reaction is performed in an aqueous state with ethoxyethane as the solvent. With all that out of the way let's focus our attention to the action space. For this reaction environemnt our action space is represented by a 6 element vector. Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na Value range: 0-1 0-1 0-1 0-1 0-1 0-1 As you might have noticed now, the reaction bench environment deals with a continuous action space. So what exactly do these continuous values represent? For the environmental conditions, in this case Volume and Temperature 0 represents a decrease in temperature or volume by dT or dV (specified in the reaction bench), 1/2 represents no change, and 1 represents an increase by dT or dV. For the chemicals, 0 represents adding no amount of that chemical to the reaction vessel, and 1 represents adding all of the originally available chemical (there is a negative reward if you try to add more chemical than is available). Now that we understand the action space I encourage you to use this reaction environment and to play around with the environmental conditions and adding the chemicals into the reaction vessel.","title":"Part 1:"},{"location":"lesson_1_react/#part-2","text":"Here I will provide instructions on how to maximize the return of this reaction environment. This is fairly simple for this task and have thus provided some script which demonstrates our strategy, and I encourage you to try your own strategy and see how it performs. In this case cour strategy is at step 1 to increase the temperature, keep the volume of solvent constant, and to add all our reagents, in this case 1-chlorohexane and Na. This gives us an action vector of: Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 1 0 0 1 Then at every next step we are going to keep the solvent volume constant and increase the temperature Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 0 0 0 0 to see this strategy in action simply run lessons/reaction_bench/reaction_wurtz_automated.py you should see a graph like this at the end and recieve a reward of the following: and now we're done! I hope you have a better sense of how the reaction environment works and the process through which an RL agent must go through to learn the environment.","title":"Part 2:"},{"location":"vessel_lesson/","text":"Vessel: Lesson Overview: In this lesson, we will be going through a class that is vital to the operation of all of our benches, the vessel class. The source code for this can be found here: chemistrylab/chem_algorithms/vessel.py . The vessel calss as it is named is meant to simulate the use of any given you might find in a chemistry lad, such as a beaker or an extraction vessel. Here we will be going through the important concepts, functions and attributes that make up the vessel class so that you can easily use it when designing your own reactions. If you want a more detailed look into each function of the vessel I suggest you go to our documentation on the data structure. Important Variables Structure Description _material_dict {'material.name': [material(), amount], ...} a dictionary holding all the material inside this vessel _solute_dict {'solute.name': {solvent.name: amount, ...}, ...} dictionary that represents the solution _event_dict {'function name': function} a dictionary holds the event functions of a vessel _event_queue [['event', parameters], ['event', parameters] ... ] a queue of events to be performed by vessel _feedback_queue [['event', parameters], ['event', parameters] ... ] a queue holding collected feedback from materials and unfinished events An example of _material_dict and _solute_dict (vessel with Na and Cl dissolved in H2O and C6H14) H2O = material.H2O() C6H14 = material.C6H14() Na = material.Na() Cl = material.Cl() Na.set_charge(1.0) Na.set_solute_flag(True) Cl.set_charge(-1.0) Cl.set_solute_flag(True) material_dict = {'H2O': [H2O, 100], 'C6H14': [C6H14, 100], 'Na': [Na, 1.0], 'Cl': [Cl, 1.0]} solute_dict = {'Na': {'H2O': 0.5, 'C6H14': 0.5}, 'Cl': {'H2O': 0.5, 'C6H14': 0.5}} Important functions Description push_event_to_queue() used to pass event into the vessel _update_materials() automatically called by push_event_to_queue(), execute events in _event_queue and _feedback_queue _merge_event_queue() merge the feedback_queue passed in, and all the default events (switches) are appended to _feedback_queue by this function The Workflow Agent choose action from the action space of an environment. The environment does the calculation and update and generate events. At the end of each action, if the action affect a vessel, use push_event_to_queue() to push the event into the vessel, if no event generated, call the function with events=None. With push_event_to_queue() called, events are pushed into the vessel. _update_materials is automatically called and perform events in the events_queue. Each event has a corresponding event function, it first update properties of the vessel, then loop over the materials inside the vessel by calling the corresponding event functions of each material. The materials' event function will return feedback by calling the push_event_to_queue(), which contains feedback and unfinished event The returned feedback is added to the _feedback_queue The the _merge_event_queue() is called on _feedback_queue, which merge the events in the feedback_queue to generate a merged_queue and add default event into it, then empty the _feedback_queue Then the merged_queue will be executed and new feedback are collected and added to _feedback_queue, which will be executed with the next action. Event Functions Function Name Description 'pour by volume' Pour from self vessel to target vessel by certain volume 'drain by pixel Drain from self vessel to target vessel by certain pixel 'fully mix' Shake self vessel to fully mix 'update material dict' Use input to update self vessel's material_dict 'update solute dict' Use input to update self vessel's solute_dict 'mix' Shake vessel of let vessel settle 'update_layer' Update self vessel's layer representation","title":"Vessel Lesson"},{"location":"vessel_lesson/#vessel-lesson","text":"","title":"Vessel: Lesson"},{"location":"vessel_lesson/#overview","text":"In this lesson, we will be going through a class that is vital to the operation of all of our benches, the vessel class. The source code for this can be found here: chemistrylab/chem_algorithms/vessel.py . The vessel calss as it is named is meant to simulate the use of any given you might find in a chemistry lad, such as a beaker or an extraction vessel. Here we will be going through the important concepts, functions and attributes that make up the vessel class so that you can easily use it when designing your own reactions. If you want a more detailed look into each function of the vessel I suggest you go to our documentation on the data structure. Important Variables Structure Description _material_dict {'material.name': [material(), amount], ...} a dictionary holding all the material inside this vessel _solute_dict {'solute.name': {solvent.name: amount, ...}, ...} dictionary that represents the solution _event_dict {'function name': function} a dictionary holds the event functions of a vessel _event_queue [['event', parameters], ['event', parameters] ... ] a queue of events to be performed by vessel _feedback_queue [['event', parameters], ['event', parameters] ... ] a queue holding collected feedback from materials and unfinished events","title":"Overview:"},{"location":"vessel_lesson/#an-example-of-_material_dict-and-_solute_dict","text":"(vessel with Na and Cl dissolved in H2O and C6H14) H2O = material.H2O() C6H14 = material.C6H14() Na = material.Na() Cl = material.Cl() Na.set_charge(1.0) Na.set_solute_flag(True) Cl.set_charge(-1.0) Cl.set_solute_flag(True) material_dict = {'H2O': [H2O, 100], 'C6H14': [C6H14, 100], 'Na': [Na, 1.0], 'Cl': [Cl, 1.0]} solute_dict = {'Na': {'H2O': 0.5, 'C6H14': 0.5}, 'Cl': {'H2O': 0.5, 'C6H14': 0.5}} Important functions Description push_event_to_queue() used to pass event into the vessel _update_materials() automatically called by push_event_to_queue(), execute events in _event_queue and _feedback_queue _merge_event_queue() merge the feedback_queue passed in, and all the default events (switches) are appended to _feedback_queue by this function","title":"An example of _material_dict and _solute_dict"},{"location":"vessel_lesson/#the-workflow","text":"Agent choose action from the action space of an environment. The environment does the calculation and update and generate events. At the end of each action, if the action affect a vessel, use push_event_to_queue() to push the event into the vessel, if no event generated, call the function with events=None. With push_event_to_queue() called, events are pushed into the vessel. _update_materials is automatically called and perform events in the events_queue. Each event has a corresponding event function, it first update properties of the vessel, then loop over the materials inside the vessel by calling the corresponding event functions of each material. The materials' event function will return feedback by calling the push_event_to_queue(), which contains feedback and unfinished event The returned feedback is added to the _feedback_queue The the _merge_event_queue() is called on _feedback_queue, which merge the events in the feedback_queue to generate a merged_queue and add default event into it, then empty the _feedback_queue Then the merged_queue will be executed and new feedback are collected and added to _feedback_queue, which will be executed with the next action.","title":"The Workflow"},{"location":"vessel_lesson/#event-functions","text":"Function Name Description 'pour by volume' Pour from self vessel to target vessel by certain volume 'drain by pixel Drain from self vessel to target vessel by certain pixel 'fully mix' Shake self vessel to fully mix 'update material dict' Use input to update self vessel's material_dict 'update solute dict' Use input to update self vessel's solute_dict 'mix' Shake vessel of let vessel settle 'update_layer' Update self vessel's layer representation","title":"Event Functions"}]}