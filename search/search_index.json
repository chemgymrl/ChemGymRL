{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ChemGymRL's documentation!","title":"Home"},{"location":"#welcome-to-chemgymrls-documentation","text":"","title":"Welcome to ChemGymRL's documentation!"},{"location":"About/","text":"About","title":"About"},{"location":"About/#about","text":"","title":"About"},{"location":"Contact/","text":"Contact Us","title":"Contact Us"},{"location":"Contact/#contact-us","text":"","title":"Contact Us"},{"location":"Developers/","text":"Developers","title":"Developers"},{"location":"Developers/#developers","text":"","title":"Developers"},{"location":"Directory/","text":"Directory","title":"Directory"},{"location":"Directory/#directory","text":"","title":"Directory"},{"location":"Glossary/","text":"Glossary","title":"Glossary"},{"location":"Glossary/#glossary","text":"","title":"Glossary"},{"location":"Installation/","text":"Installation","title":"Installation"},{"location":"Installation/#installation","text":"","title":"Installation"},{"location":"License/","text":"Citation & License","title":"Citation and Licence"},{"location":"License/#citation-license","text":"","title":"Citation &amp; License"},{"location":"Output/","text":"Output","title":"Output"},{"location":"Output/#output","text":"","title":"Output"},{"location":"QuickStart/","text":"Quick Start","title":"Quick Start"},{"location":"QuickStart/#quick-start","text":"","title":"Quick Start"},{"location":"RLalgo/","text":"Examples of Reinforcement Learning Algorithm Running and Results","title":"Examples of RL algoritm and Results"},{"location":"RLalgo/#examples-of-reinforcement-learning-algorithm-running-and-results","text":"","title":"Examples of Reinforcement Learning Algorithm Running and Results"},{"location":"Troubleshooting/","text":"Troubleshooting Hello","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting-hello","text":"","title":"Troubleshooting Hello"},{"location":"UsingCmdLine/","text":"Using Command Line","title":"Using Command Line"},{"location":"UsingCmdLine/#using-command-line","text":"","title":"Using Command Line"},{"location":"VisualizingOutput/","text":"Visualizing Output","title":"Visualizing Output"},{"location":"VisualizingOutput/#visualizing-output","text":"","title":"Visualizing Output"},{"location":"WhatIsChemGymRL/","text":"What is ChemGymRL?","title":"What is ChemGymRL?"},{"location":"WhatIsChemGymRL/#what-is-chemgymrl","text":"","title":"What is ChemGymRL?"},{"location":"custom_extraction_lesson/","text":"Building A Custom Extraction File For this tutorial we will be showing you how to create a custom extraction environment to train an RL agent on! In this case we will be doing the extraction of Methyl Red from a solution of hydrochloric acid into Ethyl Acetate. The procedure and set up of this reaction can be found at this link . Now let's get started. The extraction bench is one of the more complicated environments to build since there are a lot more actions to take in the environment and as a result a lot more to set up. As a result we are starting with a very simple, single extraction but after having implemented this it should be obvious how to extend this to larger more complicated extractions. Typically, in a new reaction or extraction it will be important to define the new materials in chemistrylab/chem_algorithms/material.py but for this case we have implemented the 2 new materials (methyl red and ethyl acetate). Go into the material file and look at the materials and familiarize yourself with the properties of each material. In your own project after creating the new materials it is then time to create the extraction environment space, and the actions that can be performed in that extraction. For a simple single extraction we can use a prebuilt environment in this case chemistrylab/extract_bench/extraction_0.py . Please take a read through the file and try to understand how actions are performed and how we set up vessels. Now we will create a new extraction bench file in the following directory chemistrylab/extract_bench , let's create a new file called methyl_red.py . In this new file we are going to use the following code: import numpy as np import gym import gym.spaces from chemistrylab.extract_bench.extract_bench_v1_engine import ExtractBenchEnv from chemistrylab.chem_algorithms import material, util, vessel # initialize extraction vessel extraction_vessel = vessel.Vessel(label='extraction_vessel', ) # initialize materials H2O = material.H2O HCl = material.HCl H = material.H Cl = material.Cl MethylRed = material.MethylRed EthylAcetate = material.EthylAcetate # material_dict # The material dict is the data-structure we use to describe the materials that will be in our vessel # found inside of our vessel, in this case it is of the form # {material_name: [material_class, quantity, unit]} # you don't need to specify a unit but if you don't we assume you are using mols material_dict = {H2O().get_name(): [H2O, 27.7], H().get_name(): [H, 2.5e-4], Cl().get_name(): [Cl, 2.5e-4], MethylRed().get_name(): [MethylRed, 9.28e-4], } # solute_dict # the solute dict describes how different materials are dissolved in others # {solute_name: {solvent_name: [quantity, unit]}} # you don't need to specify a unit but if you don't we assume you are using mols solute_dict = {H().get_name(): {H2O().get_name(): [27.7, 'mol']}, Cl().get_name(): {H2O().get_name(): [27.7, 'mol']}, MethylRed().get_name(): {H2O().get_name(): [500, 'ml']}, } # this function checks if we have poured too many materials in our vessel and if we have it returns a vessel # with the appropriate amount of materials lost material_dict, solute_dict, _ = util.check_overflow(material_dict=material_dict, solute_dict=solute_dict, v_max=extraction_vessel.get_max_volume(), ) # Here we push events that update the material dictionary, solute dictionary and then mix all of the materials together event_1 = ['update material dict', material_dict] event_2 = ['update solute dict', solute_dict] event_3 = ['fully mix'] extraction_vessel.push_event_to_queue(events=None, feedback=[event_1], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_2], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_3], dt=0) # Here is our initialization of the extraction bench environment # Make sure to give it a unique name and specify the correct extraction bench that we have defined above # in this case our extractor is EthylAcetate because it is less polar than water, this in turn allows us # to extract the desired material methyl red class ExtractWorld_MethylRed(ExtractBenchEnv): def __init__(self): super(ExtractWorld_MethylRed, self).__init__( extraction='extraction_0', extraction_vessel=extraction_vessel, target_material='methyl red', extractor=EthylAcetate ) Now we just have to add some code to allow the new environment to be recognized by gym. In the following file chemistrylab/__init__.py we will add the following line of code: register( id='MethylRed_Extract-v1', entry_point='chemistrylab.extract_bench.methyl_red:ExtractWorld_MethylRed', max_episode_steps=100 ) Now we're done! To test that these changes have worked, simply run the following code: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Extract' in env_spec.id] print(env_ids) You should see in the output MethylRed_Extract-v1 # ['WurtzExtract-v1', 'Oil_Water_Extract-v1', 'MethylRed_Extract-v1', 'MethylRed_Extract-v2']","title":"Custom Extraction Lesson"},{"location":"custom_extraction_lesson/#building-a-custom-extraction-file","text":"For this tutorial we will be showing you how to create a custom extraction environment to train an RL agent on! In this case we will be doing the extraction of Methyl Red from a solution of hydrochloric acid into Ethyl Acetate. The procedure and set up of this reaction can be found at this link . Now let's get started. The extraction bench is one of the more complicated environments to build since there are a lot more actions to take in the environment and as a result a lot more to set up. As a result we are starting with a very simple, single extraction but after having implemented this it should be obvious how to extend this to larger more complicated extractions. Typically, in a new reaction or extraction it will be important to define the new materials in chemistrylab/chem_algorithms/material.py but for this case we have implemented the 2 new materials (methyl red and ethyl acetate). Go into the material file and look at the materials and familiarize yourself with the properties of each material. In your own project after creating the new materials it is then time to create the extraction environment space, and the actions that can be performed in that extraction. For a simple single extraction we can use a prebuilt environment in this case chemistrylab/extract_bench/extraction_0.py . Please take a read through the file and try to understand how actions are performed and how we set up vessels. Now we will create a new extraction bench file in the following directory chemistrylab/extract_bench , let's create a new file called methyl_red.py . In this new file we are going to use the following code: import numpy as np import gym import gym.spaces from chemistrylab.extract_bench.extract_bench_v1_engine import ExtractBenchEnv from chemistrylab.chem_algorithms import material, util, vessel # initialize extraction vessel extraction_vessel = vessel.Vessel(label='extraction_vessel', ) # initialize materials H2O = material.H2O HCl = material.HCl H = material.H Cl = material.Cl MethylRed = material.MethylRed EthylAcetate = material.EthylAcetate # material_dict # The material dict is the data-structure we use to describe the materials that will be in our vessel # found inside of our vessel, in this case it is of the form # {material_name: [material_class, quantity, unit]} # you don't need to specify a unit but if you don't we assume you are using mols material_dict = {H2O().get_name(): [H2O, 27.7], H().get_name(): [H, 2.5e-4], Cl().get_name(): [Cl, 2.5e-4], MethylRed().get_name(): [MethylRed, 9.28e-4], } # solute_dict # the solute dict describes how different materials are dissolved in others # {solute_name: {solvent_name: [quantity, unit]}} # you don't need to specify a unit but if you don't we assume you are using mols solute_dict = {H().get_name(): {H2O().get_name(): [27.7, 'mol']}, Cl().get_name(): {H2O().get_name(): [27.7, 'mol']}, MethylRed().get_name(): {H2O().get_name(): [500, 'ml']}, } # this function checks if we have poured too many materials in our vessel and if we have it returns a vessel # with the appropriate amount of materials lost material_dict, solute_dict, _ = util.check_overflow(material_dict=material_dict, solute_dict=solute_dict, v_max=extraction_vessel.get_max_volume(), ) # Here we push events that update the material dictionary, solute dictionary and then mix all of the materials together event_1 = ['update material dict', material_dict] event_2 = ['update solute dict', solute_dict] event_3 = ['fully mix'] extraction_vessel.push_event_to_queue(events=None, feedback=[event_1], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_2], dt=0) extraction_vessel.push_event_to_queue(events=None, feedback=[event_3], dt=0) # Here is our initialization of the extraction bench environment # Make sure to give it a unique name and specify the correct extraction bench that we have defined above # in this case our extractor is EthylAcetate because it is less polar than water, this in turn allows us # to extract the desired material methyl red class ExtractWorld_MethylRed(ExtractBenchEnv): def __init__(self): super(ExtractWorld_MethylRed, self).__init__( extraction='extraction_0', extraction_vessel=extraction_vessel, target_material='methyl red', extractor=EthylAcetate ) Now we just have to add some code to allow the new environment to be recognized by gym. In the following file chemistrylab/__init__.py we will add the following line of code: register( id='MethylRed_Extract-v1', entry_point='chemistrylab.extract_bench.methyl_red:ExtractWorld_MethylRed', max_episode_steps=100 ) Now we're done! To test that these changes have worked, simply run the following code: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Extract' in env_spec.id] print(env_ids) You should see in the output MethylRed_Extract-v1 # ['WurtzExtract-v1', 'Oil_Water_Extract-v1', 'MethylRed_Extract-v1', 'MethylRed_Extract-v2']","title":"Building A Custom Extraction File"},{"location":"custom_reaction_lesson/","text":"Building A Custom Reaction File For this tutorial we are going to be creating a very simple reaction NaCl aq -> Na + aq + Cl - aq In order to start with creating an environment for this reaction we first have to create a reaction file which simulates the mechanics of this decomposition. In the directory chemistrylab/reactions you will find a list of reactions that looks something like this: For this case we will create a new reaction file from the reaction template file template_reaction.py , and let's name it decomp_reaction.py . The first change we have to make is to the list of reactants, products and solutes located at line 42 # names of the reactants and products in all reactions # a list of the names of all reactants that are to be used in a reaction REACTANTS = [] # a list of all the names of the reactants that are going to be produced by the reaction PRODUCTS = [] ALL_MATERIALS = REACTANTS + PRODUCTS # specify the solute in which the reaction is meant to take place in SOLUTES = [] we change the above to the following: REACTANTS = ['NaCl'] PRODUCTS = ['Na', 'Cl'] ALL_MATERIALS = REACTANTS + PRODUCTS SOLUTES = ['H2O'] In this case we are letting the reaction file know what reagents we are using and the desired product so that we can easily track and display their concentrations. Next up we have to look at our spectra parameters. The specification of which exact spectra variables we use is not important, but it is important to have the right number of spectra so we can generate absorbance data. The following line of code is located at line 126 in the initialization function of the Reaction class if overlap: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) else: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) We change the above to look like: if overlap: self.params.append(spec.S_3_3) # spectra for NaCl self.params.append(spec.S_6) # spectra for the Na self.params.append(spec.S_7) # spectra for the Cl else: self.params.append(spec.S_8) # spectra for NaCl self.params.append(spec.S_1) # spectra for the Na self.params.append(spec.S_3) # spectra for the Cl A note on the spectra that the numbers have no significance, so feel free to pick any spectra you wish. Now that we have our spectra corrected we now have to change the update function of our file. For these reactions we use an ODE solver to calculate the change in concentration over time. As such we have to change some parameters on how we update the rates of reaction. # obtain the concentration (all concentrations are in mol/m**3) C = self.get_concentration(V) # define a space to contain the changes in concentration to each chemical dC = np.zeros(self.n.shape[0]) # define the reaction constant for each reaction k1 = A1 * np.exp((-1 * E1)/(R * T)) # define the rate of each reaction self.rate[0] = k1 * C[0] * dt # calculate and store the changes in concentration of each chemical dC[0] = (-1.0 * self.rate[0]) dC[1] = (1.0 * self.rate[0]) dc[2] = (1.0 * self.rate[0]) In this case we don't need to update these parameters but depending on the number of simultaneous reactions and the rates and how they relate to the concentration of a substance there will need to be additional parameters added, this can be seen in wurtz_reaction.py : # set the pre-exponential constant using the above scaling factor for proper dimensionality A0 = 1.0 / scaling_factor # Reaction 0 A1 = 1.0 / scaling_factor # Reaction 1 A2 = 1.0 / scaling_factor # Reaction 2 A3 = 1.0 / scaling_factor # Reaction 3 A4 = 1.0 / scaling_factor # Reaction 4 A5 = 1.0 / scaling_factor # Reaction 5 # set the activation energies for each reaction constant E0 = 1.0 E1 = 1.0 E2 = 1.0 E3 = 1.0 E4 = 1.0 E5 = 1.0 # define the reaction constant for each reaction; k0 = A0 * np.exp((-1 * E0)/(R * T)) k1 = A1 * np.exp((-1 * E1)/(R * T)) k2 = A2 * np.exp((-1 * E2)/(R * T)) k3 = A3 * np.exp((-1 * E3)/(R * T)) k4 = A4 * np.exp((-1 * E4)/(R * T)) k5 = A5 * np.exp((-1 * E5)/(R * T)) # define the rate of each reaction; # note the reactants in the concentration array (C) are in # the order of the reactants in the `REACTANTS` variable; # using the stoichiometric ratio in the rate exponentials gives the following rates: self.rate[0] = k0 * (C[0] ** 2) * (C[1] ** 0) * (C[2] ** 0) * (C[3] ** 1) self.rate[1] = k1 * (C[0] ** 1) * (C[1] ** 1) * (C[2] ** 0) * (C[3] ** 1) self.rate[2] = k2 * (C[0] ** 1) * (C[1] ** 0) * (C[2] ** 1) * (C[3] ** 1) self.rate[3] = k3 * (C[0] ** 0) * (C[1] ** 2) * (C[2] ** 0) * (C[3] ** 1) self.rate[4] = k4 * (C[0] ** 0) * (C[1] ** 1) * (C[2] ** 1) * (C[3] ** 1) self.rate[5] = k5 * (C[0] ** 0) * (C[1] ** 0) * (C[2] ** 2) * (C[3] ** 1) # calculate and store the changes in concentration of each chemical; # recall: change in concentration = molar concentration * rate * dt # ie. for A + 2B --> C and A + C --> D as parallel reactions # change in A = (-1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in B = (-2 * rate of reaction 1 * dt) # change in C = (+1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in D = (+1 * rate of reaction 2 * dt) # assuming both reactions have the same time-step, which is true for all reactions in this file dC[0] = (-2.0 * self.rate[0]) + (-1.0 * self.rate[1]) + (-1.0 * self.rate[2]) * dt # change in 1-chlorohexane dC[1] = (-1.0 * self.rate[1]) + (-2.0 * self.rate[3]) + (-1.0 * self.rate[4]) * dt # change in 2-chlorohexane dC[2] = (-2.0 * self.rate[2]) + (-1.0 * self.rate[4]) + (-2.0 * self.rate[5]) * dt # change in 3-chlorohexane dC[3] = -2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in Na dC[4] = 1.0 * self.rate[0] * dt # change in dodecane dC[5] = 1.0 * self.rate[1] * dt # change in 5-methylundecane dC[6] = 1.0 * self.rate[2] * dt # change in 4-ethyldecane dC[7] = 1.0 * self.rate[3] * dt # change in 5,6-dimethyldecane dC[8] = 1.0 * self.rate[4] * dt # change in 4-ethyl-5-methylnonane dC[9] = 1.0 * self.rate[5] * dt # change in 4,5-diethyloctane dC[10] = 2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in NaCl As far as the reaction file, it is now set up and ready to go. Now inorder to use the reaction we need to make a simple change to the reaction bench engine located chemistrylab/reaction_bench/reaction_bench_v0_engine.py in this case you should duplicate this file and rename the file reaction_bench_v0_engine_decomp at the top of the file you should see a line like the one below where we import the reaction that the engine will use: from chemistrylab.reactions.wurtz_reaction import Reaction We will change the import so that we import the new reaction we just created from chemistrylab.reactions.decomp_reaction import Reaction It will also be easier for us to change the name of the engine class from: ReactionBenchEnv to ReactionBenchEnvDecomp We are now onto the last 2 additions that will allow us to use this reaction environment. In this file chemistrylab/reaction_bench/reaction_bench_v0.py we are going to add some code that will allow us to initialize our new reaction environment so that we can then register it and use it. At the bottom of this file we will add the following lines of code: class ReactionBenchEnv_1(ReactionBenchEnvDecomp): def __init__(self): super(ReactionBenchEnv_1, self).__init__( materials=[ {\"Material\": \"NaCl\", \"Initial\": 1}, ], solutes=[ {\"Solute\": \"H2O\", \"Initial\": 1} ], desired=\"Na\", overlap=False ) This code simply sets up the environement we will be using. So in this case we establish the materials that the reaction will use and the initial quantity of that substance in mols. We then also establish our solute, in this case, 1 mol of water. Lastly we specify our desired material so that we can calculate the reward which the RL agent will recieve. This takes us to the final step which is registering the environment with gym. In this file: chemistrylab/__init__.py we are going to add a few more lines of code. register( id='DecompReactLesson-v0', entry_point='chemistrylab.reaction_bench.reaction_bench_v0:ReactionBenchEnv_1', max_episode_steps=20 ) This code simply tells gym where to find our new environment. Now we're done if you run the following code you should now be able to see our new environment: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'React' in env_spec.id] print(env_ids) #['WurtzReact-v0', 'WurtzReact_overlap-v0', 'DecompReactLesson-v0'] Here we can clearly see that our environment has been added!","title":"Custom Reaction Lesson"},{"location":"custom_reaction_lesson/#building-a-custom-reaction-file","text":"For this tutorial we are going to be creating a very simple reaction NaCl aq -> Na + aq + Cl - aq In order to start with creating an environment for this reaction we first have to create a reaction file which simulates the mechanics of this decomposition. In the directory chemistrylab/reactions you will find a list of reactions that looks something like this: For this case we will create a new reaction file from the reaction template file template_reaction.py , and let's name it decomp_reaction.py . The first change we have to make is to the list of reactants, products and solutes located at line 42 # names of the reactants and products in all reactions # a list of the names of all reactants that are to be used in a reaction REACTANTS = [] # a list of all the names of the reactants that are going to be produced by the reaction PRODUCTS = [] ALL_MATERIALS = REACTANTS + PRODUCTS # specify the solute in which the reaction is meant to take place in SOLUTES = [] we change the above to the following: REACTANTS = ['NaCl'] PRODUCTS = ['Na', 'Cl'] ALL_MATERIALS = REACTANTS + PRODUCTS SOLUTES = ['H2O'] In this case we are letting the reaction file know what reagents we are using and the desired product so that we can easily track and display their concentrations. Next up we have to look at our spectra parameters. The specification of which exact spectra variables we use is not important, but it is important to have the right number of spectra so we can generate absorbance data. The following line of code is located at line 126 in the initialization function of the Reaction class if overlap: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) else: # add spectra to params make sure to add spectra as required self.params.append(spec.S_1) We change the above to look like: if overlap: self.params.append(spec.S_3_3) # spectra for NaCl self.params.append(spec.S_6) # spectra for the Na self.params.append(spec.S_7) # spectra for the Cl else: self.params.append(spec.S_8) # spectra for NaCl self.params.append(spec.S_1) # spectra for the Na self.params.append(spec.S_3) # spectra for the Cl A note on the spectra that the numbers have no significance, so feel free to pick any spectra you wish. Now that we have our spectra corrected we now have to change the update function of our file. For these reactions we use an ODE solver to calculate the change in concentration over time. As such we have to change some parameters on how we update the rates of reaction. # obtain the concentration (all concentrations are in mol/m**3) C = self.get_concentration(V) # define a space to contain the changes in concentration to each chemical dC = np.zeros(self.n.shape[0]) # define the reaction constant for each reaction k1 = A1 * np.exp((-1 * E1)/(R * T)) # define the rate of each reaction self.rate[0] = k1 * C[0] * dt # calculate and store the changes in concentration of each chemical dC[0] = (-1.0 * self.rate[0]) dC[1] = (1.0 * self.rate[0]) dc[2] = (1.0 * self.rate[0]) In this case we don't need to update these parameters but depending on the number of simultaneous reactions and the rates and how they relate to the concentration of a substance there will need to be additional parameters added, this can be seen in wurtz_reaction.py : # set the pre-exponential constant using the above scaling factor for proper dimensionality A0 = 1.0 / scaling_factor # Reaction 0 A1 = 1.0 / scaling_factor # Reaction 1 A2 = 1.0 / scaling_factor # Reaction 2 A3 = 1.0 / scaling_factor # Reaction 3 A4 = 1.0 / scaling_factor # Reaction 4 A5 = 1.0 / scaling_factor # Reaction 5 # set the activation energies for each reaction constant E0 = 1.0 E1 = 1.0 E2 = 1.0 E3 = 1.0 E4 = 1.0 E5 = 1.0 # define the reaction constant for each reaction; k0 = A0 * np.exp((-1 * E0)/(R * T)) k1 = A1 * np.exp((-1 * E1)/(R * T)) k2 = A2 * np.exp((-1 * E2)/(R * T)) k3 = A3 * np.exp((-1 * E3)/(R * T)) k4 = A4 * np.exp((-1 * E4)/(R * T)) k5 = A5 * np.exp((-1 * E5)/(R * T)) # define the rate of each reaction; # note the reactants in the concentration array (C) are in # the order of the reactants in the `REACTANTS` variable; # using the stoichiometric ratio in the rate exponentials gives the following rates: self.rate[0] = k0 * (C[0] ** 2) * (C[1] ** 0) * (C[2] ** 0) * (C[3] ** 1) self.rate[1] = k1 * (C[0] ** 1) * (C[1] ** 1) * (C[2] ** 0) * (C[3] ** 1) self.rate[2] = k2 * (C[0] ** 1) * (C[1] ** 0) * (C[2] ** 1) * (C[3] ** 1) self.rate[3] = k3 * (C[0] ** 0) * (C[1] ** 2) * (C[2] ** 0) * (C[3] ** 1) self.rate[4] = k4 * (C[0] ** 0) * (C[1] ** 1) * (C[2] ** 1) * (C[3] ** 1) self.rate[5] = k5 * (C[0] ** 0) * (C[1] ** 0) * (C[2] ** 2) * (C[3] ** 1) # calculate and store the changes in concentration of each chemical; # recall: change in concentration = molar concentration * rate * dt # ie. for A + 2B --> C and A + C --> D as parallel reactions # change in A = (-1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in B = (-2 * rate of reaction 1 * dt) # change in C = (+1 * rate of reaction 1 * dt) + (-1 * rate of reaction 2 * dt) # change in D = (+1 * rate of reaction 2 * dt) # assuming both reactions have the same time-step, which is true for all reactions in this file dC[0] = (-2.0 * self.rate[0]) + (-1.0 * self.rate[1]) + (-1.0 * self.rate[2]) * dt # change in 1-chlorohexane dC[1] = (-1.0 * self.rate[1]) + (-2.0 * self.rate[3]) + (-1.0 * self.rate[4]) * dt # change in 2-chlorohexane dC[2] = (-2.0 * self.rate[2]) + (-1.0 * self.rate[4]) + (-2.0 * self.rate[5]) * dt # change in 3-chlorohexane dC[3] = -2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in Na dC[4] = 1.0 * self.rate[0] * dt # change in dodecane dC[5] = 1.0 * self.rate[1] * dt # change in 5-methylundecane dC[6] = 1.0 * self.rate[2] * dt # change in 4-ethyldecane dC[7] = 1.0 * self.rate[3] * dt # change in 5,6-dimethyldecane dC[8] = 1.0 * self.rate[4] * dt # change in 4-ethyl-5-methylnonane dC[9] = 1.0 * self.rate[5] * dt # change in 4,5-diethyloctane dC[10] = 2.0 * (self.rate[0] + self.rate[1] + self.rate[2] + self.rate[3] + self.rate[4] + self.rate[5]) * dt # change in NaCl As far as the reaction file, it is now set up and ready to go. Now inorder to use the reaction we need to make a simple change to the reaction bench engine located chemistrylab/reaction_bench/reaction_bench_v0_engine.py in this case you should duplicate this file and rename the file reaction_bench_v0_engine_decomp at the top of the file you should see a line like the one below where we import the reaction that the engine will use: from chemistrylab.reactions.wurtz_reaction import Reaction We will change the import so that we import the new reaction we just created from chemistrylab.reactions.decomp_reaction import Reaction It will also be easier for us to change the name of the engine class from: ReactionBenchEnv to ReactionBenchEnvDecomp We are now onto the last 2 additions that will allow us to use this reaction environment. In this file chemistrylab/reaction_bench/reaction_bench_v0.py we are going to add some code that will allow us to initialize our new reaction environment so that we can then register it and use it. At the bottom of this file we will add the following lines of code: class ReactionBenchEnv_1(ReactionBenchEnvDecomp): def __init__(self): super(ReactionBenchEnv_1, self).__init__( materials=[ {\"Material\": \"NaCl\", \"Initial\": 1}, ], solutes=[ {\"Solute\": \"H2O\", \"Initial\": 1} ], desired=\"Na\", overlap=False ) This code simply sets up the environement we will be using. So in this case we establish the materials that the reaction will use and the initial quantity of that substance in mols. We then also establish our solute, in this case, 1 mol of water. Lastly we specify our desired material so that we can calculate the reward which the RL agent will recieve. This takes us to the final step which is registering the environment with gym. In this file: chemistrylab/__init__.py we are going to add a few more lines of code. register( id='DecompReactLesson-v0', entry_point='chemistrylab.reaction_bench.reaction_bench_v0:ReactionBenchEnv_1', max_episode_steps=20 ) This code simply tells gym where to find our new environment. Now we're done if you run the following code you should now be able to see our new environment: from gym import envs all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'React' in env_spec.id] print(env_ids) #['WurtzReact-v0', 'WurtzReact_overlap-v0', 'DecompReactLesson-v0'] Here we can clearly see that our environment has been added!","title":"Building A Custom Reaction File"},{"location":"input/","text":"Input","title":"Input"},{"location":"input/#input","text":"","title":"Input"},{"location":"jenkins/","text":"Jenkins: Pipelinefile Below here is the file that you must add to your branch, however there are a few changes that must be made for your branch. Create a file named Jenkinsfile at the root of the repository so in our case chemistrygym/Jenkinsfile and copy the text below into the file. Please then make the appropriate changes highlighted by the comments. This file tells jenkins what to buildand as such you must include the file inorder for our tests to run. pipeline { agent any stages { stage('Cleanup Workspace') { steps { cleanWs() sh \"\"\" echo \"Cleaned Up Workspace For Project\" \"\"\" } } stage('pull git'){ steps { // !!!!!! Change branch name below to match the branch you are working in !!!!!! git branch: 'YOUR_BRANCH_HERE', credentialsId: '1de24870-cdba-4190-a8fb-f0508d298280', url: 'https://github.com/CLEANit/chemistrygym.git' } } stage('set up venv and install dependencies'){ steps { sh 'python -m venv test_env' sh 'ls test_env' sh 'ls test_env/bin' sh '. ./test_env/bin/activate' sh 'pip3 install -r requirements.txt' } } stage(' Unit Testing Reaction') { steps { sh 'cd tests/unit/reaction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } stage(' Unit Testing Extraction') { steps { sh 'cd ../tests/unit/extraction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } // if you have another unit test directory that is not being run in the build you may use the sample code below to test it /* stage('Unit Testing TEST FILE') { steps { sh 'cd ../tests/unit/TEST_DIRECTORY' sh 'python3 -m unittest discover -p \"*_test.py\"' } } */ } }","title":"Using Jenkins"},{"location":"jenkins/#jenkins-pipelinefile","text":"Below here is the file that you must add to your branch, however there are a few changes that must be made for your branch. Create a file named Jenkinsfile at the root of the repository so in our case chemistrygym/Jenkinsfile and copy the text below into the file. Please then make the appropriate changes highlighted by the comments. This file tells jenkins what to buildand as such you must include the file inorder for our tests to run. pipeline { agent any stages { stage('Cleanup Workspace') { steps { cleanWs() sh \"\"\" echo \"Cleaned Up Workspace For Project\" \"\"\" } } stage('pull git'){ steps { // !!!!!! Change branch name below to match the branch you are working in !!!!!! git branch: 'YOUR_BRANCH_HERE', credentialsId: '1de24870-cdba-4190-a8fb-f0508d298280', url: 'https://github.com/CLEANit/chemistrygym.git' } } stage('set up venv and install dependencies'){ steps { sh 'python -m venv test_env' sh 'ls test_env' sh 'ls test_env/bin' sh '. ./test_env/bin/activate' sh 'pip3 install -r requirements.txt' } } stage(' Unit Testing Reaction') { steps { sh 'cd tests/unit/reaction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } stage(' Unit Testing Extraction') { steps { sh 'cd ../tests/unit/extraction_bench' sh 'python3 -m unittest discover -p \"*_test.py\"' } } // if you have another unit test directory that is not being run in the build you may use the sample code below to test it /* stage('Unit Testing TEST FILE') { steps { sh 'cd ../tests/unit/TEST_DIRECTORY' sh 'python3 -m unittest discover -p \"*_test.py\"' } } */ } }","title":"Jenkins: Pipelinefile"},{"location":"lesson_1_distillation/","text":"Distillation Bench: Lesson 1 Familiarizing Actions for the Distillation Bench In this tutorial, we will be going through how the distillation environment works. We will be taking the tests/test_extract_vessel.pickle which is a pickle file generated when we ran the extraction bench. It is important to know that before running the distillation bench, you must first complete both reaction and extraction, in order to follow the workflow our environment. To find out more, take a look at the readme.md file on our github. Before we start talking about loading and running the environment, let's first familiarize ourselves with what's actually going on in the experiment. Distillation Process Explained In the distillation environment there are 3 main containers or vessels. vessel label boiling vessel BV beaker 1/condensation vessel B1 beaker 2/storage vessel B2 The boiling vessel (BV) contains all the materials at the initial state of the experiment. Beaker 1 (B1) can be thought of as a condensation vessel which is connected to the distillation vessel via a tube and this will contain all the materials that are being boiled off. Beaker 2 (B2) is then the storage vessel, where the condensation vessel can be emptied, in order to make room for other material. The point of the process is to extract a target material from the boiling vessel, which contains numerous materials, and we do this by utilizing the different material's boiling points. Typically the process begins by raising the temperature of the BV which allows certain materials in that vessel to boil off into the condensation vessel or B1. As a material's boiling point is reached, any more temperature added from this point will act to evaporate it. The now gaseous material will rise out of the boiling vessel into the tube that feeds into the condensation vessel where it will condense back into its liquid form. In this virtual experiment it is assumed that this takes place instantaneously. The amount of material evaporated is dependent on the enthalpy of vapour of material being evaporated. Once the entirety of the material has been boiled off, the condensation vessel is drained into the storage vessel. Now the condensation vessel is empty, the boiling vessel's temperature can then be raised more until the next lowest boiling point is reached, thus repeating the process. The process is repeated until the desired material has been completely evaporated from the boiling vessel into condensation vessel. From this point on the desired material is completely isolated and we obtain a hopefully pure sample. We can then choose to end the experiment. In lesson 3 in these sets of tutorial for the distillation bench, we will try to get a high reward by obtaining a high molar amount of pure dodecane in our condensation vessel. For this tutorial, we will just familiarize ourselves with the basic actions, fundamental theory behind distillation, and how you can run the environment on your own! Running the environment We will first start by importing the necessary required modules, both external and local. By now this step should seem very familiar as we have done them in the reaction and extraction lessons. %matplotlib inline # import all the required external modules import gym import numpy as np import os import pickle import sys from time import sleep from gym import envs import matplotlib.pyplot as plt import pandas as pd # ensure all necessary modules can be found sys.path.append('../') sys.path.append(\"../chemistrylab/reactions\") # to access all reactions # import local modules import chemistrylab We can see all the possible variations of the distillation bench environment which can vary depending on the input vessel (in this case the test_extract_vessel.pickle ), which is loaded into the boil vessel, as well as the target material. In this and following tutorials our target material will be dodecane # show all environments for distillation bench all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Distillation' in env_spec.id] print(env_ids) We then get prompted with a message asking us to choose the environment we want to run. This is based off the indexing in the environment array we saw from the last cell. # allows user to pick which environment they want to use # initializes environment select_env = int(input(f\"Enter a number to choose which environment you want to run (0 - {len(env_ids) - 1}): \\n\")) env = gym.make(env_ids[select_env]) render_mode = \"human\" #select how graphs are rendered We initialize done to False so our agent can run the experiment. We run reset() to return an initial observation. done = False __ = env.reset() print('\\n') Here we have the different possible actions that we can take with the environment. The action_set is an array indexed correspondingly to the action we want to perform. The action_space is a multidiscrete action space of shape [6 10]. The first index allows us to choose from the action set. The second index allows us to pick a multiplier that will affect the action variably depending on our chosen multiplier. For example, the following pair of numbers will add a great amount of heat compared to a multiplier of 6. Action: 0 Action Multiplier: 10 Here is a complete explanation of each action. Again, action[0] indicates the the event which is to take place. Action[1] is a number representing the multiplier for the event. action[0] 0 Add/Remove Heat (Heat Value multiplier, relative of maximal heat change) 1 Pour BV into B1 (Volume multiplier, relative to max_vessel_volume) 2 Pour B1 into B2 (Volume multiplier, relative to max_vessel_volume) 3 Pour B1 into BV (Volume multiplier, relative to max_vessel_volume) 4 Pour B2 into BV (Volume multiplier, relative to max_vessel_volume) 5 Done (Value doesn't matter) action_set = ['Add/Remove Heat', 'Pour BV into B1', 'Pour B1 into B2', 'Pour B1 into BV', 'Pour B2 into BV', 'Done'] assert env.action_space.shape[0] == 2 total_steps=0 total_reward=0 Note that the multiplier affects each action differently. For examply the way the agents chosen multiplier affects heat change is given by the following code: Typically an agent will choose actions based on what will give a higher reward, and higher reward is given by getting a high molar amount and concentraion of the desired material (in our case dodecane) in a particular vessel. Please input the following action and multipliers: Step Action Multiplier 0 0 8 1 2 10 2 0 6 3 3 10 4 1 10 5 4 10 6 5 0 while not done: action = np.zeros(env.action_space.shape[0]) for index, action_desc in enumerate(action_set): print(f'{index}: {action_desc}') print('Please enter an action and an action multiplier') for i in range(2): message = 'Action' if i == 1: message = 'Action Multiplier:' action[i] = int(input(f'{message}: ')) # perform the action and update the reward state, reward, done, __ = env.step(action) print('-----------------------------------------') print('total_steps: ', total_steps) print('reward: %.2f ' % reward) total_reward += reward print('total reward: %.2f ' % total_reward) print('Temperature of boiling vessel: %.1f ' % env.boil_vessel.temperature, ' K \\n') # print(state) # render the plot env.render(mode=render_mode) # sleep(1) #increment one step total_steps += 1 Step 0: Adding temperature to the vessel action multiplier 0 8 This will result in a temperature reaching the boiling point of water, which you will notice is now boiled off in beaker_0 (or the condensation vessel) Step 1: Pour from condensation to storage vessel action multiplier 2 10 We can then see that storage vessel is now filled with the H2O poured from the condensation vessel. *plot not fixed yet * Step 2: Add some more temperature action multiplier 0 6 Step 3: Pouring back from condensation vessel to boiling vessel action multiplier 3 10 You should see now that everything from the condensation vessel is back in the boiling vessel. ---Should insert graph here but it doesn't show the action correctly--- Step 4: Pour everything from boiling vessel into condensation vessel action multiplier 1 10 Notice now that all the materials are in the condensation vessel. Step 5: Pour the originally boiled off H2O in the storage vessel into the boiling vessel action multiplier 4 10 Now you can see that the H2O which was previously in the storage vessel, is now in the boiling vessel. Step 6: Ending the experiment action multiplier 5 0 End of the lesson This concludes the end of our tutorial. Hopefully you got a chance to see how the basic actions in the distillation environment works and see how you can use the agent in RL applications to maximize the distillation of a desired material. In the next tutorial we will perform 2 experiments where we heat up the boiling vessel to the maximum temperature it can reach, and vice versa where we cool it to the lowest temperature.","title":"Distillation Bench Tutorial, Lesson 1"},{"location":"lesson_1_distillation/#distillation-bench-lesson-1","text":"","title":"Distillation Bench: Lesson 1"},{"location":"lesson_1_distillation/#familiarizing-actions-for-the-distillation-bench","text":"In this tutorial, we will be going through how the distillation environment works. We will be taking the tests/test_extract_vessel.pickle which is a pickle file generated when we ran the extraction bench. It is important to know that before running the distillation bench, you must first complete both reaction and extraction, in order to follow the workflow our environment. To find out more, take a look at the readme.md file on our github. Before we start talking about loading and running the environment, let's first familiarize ourselves with what's actually going on in the experiment.","title":"Familiarizing Actions for the Distillation Bench"},{"location":"lesson_1_distillation/#distillation-process-explained","text":"In the distillation environment there are 3 main containers or vessels. vessel label boiling vessel BV beaker 1/condensation vessel B1 beaker 2/storage vessel B2 The boiling vessel (BV) contains all the materials at the initial state of the experiment. Beaker 1 (B1) can be thought of as a condensation vessel which is connected to the distillation vessel via a tube and this will contain all the materials that are being boiled off. Beaker 2 (B2) is then the storage vessel, where the condensation vessel can be emptied, in order to make room for other material. The point of the process is to extract a target material from the boiling vessel, which contains numerous materials, and we do this by utilizing the different material's boiling points. Typically the process begins by raising the temperature of the BV which allows certain materials in that vessel to boil off into the condensation vessel or B1. As a material's boiling point is reached, any more temperature added from this point will act to evaporate it. The now gaseous material will rise out of the boiling vessel into the tube that feeds into the condensation vessel where it will condense back into its liquid form. In this virtual experiment it is assumed that this takes place instantaneously. The amount of material evaporated is dependent on the enthalpy of vapour of material being evaporated. Once the entirety of the material has been boiled off, the condensation vessel is drained into the storage vessel. Now the condensation vessel is empty, the boiling vessel's temperature can then be raised more until the next lowest boiling point is reached, thus repeating the process. The process is repeated until the desired material has been completely evaporated from the boiling vessel into condensation vessel. From this point on the desired material is completely isolated and we obtain a hopefully pure sample. We can then choose to end the experiment. In lesson 3 in these sets of tutorial for the distillation bench, we will try to get a high reward by obtaining a high molar amount of pure dodecane in our condensation vessel. For this tutorial, we will just familiarize ourselves with the basic actions, fundamental theory behind distillation, and how you can run the environment on your own!","title":"Distillation Process Explained"},{"location":"lesson_1_distillation/#running-the-environment","text":"We will first start by importing the necessary required modules, both external and local. By now this step should seem very familiar as we have done them in the reaction and extraction lessons. %matplotlib inline # import all the required external modules import gym import numpy as np import os import pickle import sys from time import sleep from gym import envs import matplotlib.pyplot as plt import pandas as pd # ensure all necessary modules can be found sys.path.append('../') sys.path.append(\"../chemistrylab/reactions\") # to access all reactions # import local modules import chemistrylab We can see all the possible variations of the distillation bench environment which can vary depending on the input vessel (in this case the test_extract_vessel.pickle ), which is loaded into the boil vessel, as well as the target material. In this and following tutorials our target material will be dodecane # show all environments for distillation bench all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Distillation' in env_spec.id] print(env_ids) We then get prompted with a message asking us to choose the environment we want to run. This is based off the indexing in the environment array we saw from the last cell. # allows user to pick which environment they want to use # initializes environment select_env = int(input(f\"Enter a number to choose which environment you want to run (0 - {len(env_ids) - 1}): \\n\")) env = gym.make(env_ids[select_env]) render_mode = \"human\" #select how graphs are rendered We initialize done to False so our agent can run the experiment. We run reset() to return an initial observation. done = False __ = env.reset() print('\\n') Here we have the different possible actions that we can take with the environment. The action_set is an array indexed correspondingly to the action we want to perform. The action_space is a multidiscrete action space of shape [6 10]. The first index allows us to choose from the action set. The second index allows us to pick a multiplier that will affect the action variably depending on our chosen multiplier. For example, the following pair of numbers will add a great amount of heat compared to a multiplier of 6. Action: 0 Action Multiplier: 10 Here is a complete explanation of each action. Again, action[0] indicates the the event which is to take place. Action[1] is a number representing the multiplier for the event. action[0] 0 Add/Remove Heat (Heat Value multiplier, relative of maximal heat change) 1 Pour BV into B1 (Volume multiplier, relative to max_vessel_volume) 2 Pour B1 into B2 (Volume multiplier, relative to max_vessel_volume) 3 Pour B1 into BV (Volume multiplier, relative to max_vessel_volume) 4 Pour B2 into BV (Volume multiplier, relative to max_vessel_volume) 5 Done (Value doesn't matter) action_set = ['Add/Remove Heat', 'Pour BV into B1', 'Pour B1 into B2', 'Pour B1 into BV', 'Pour B2 into BV', 'Done'] assert env.action_space.shape[0] == 2 total_steps=0 total_reward=0 Note that the multiplier affects each action differently. For examply the way the agents chosen multiplier affects heat change is given by the following code: Typically an agent will choose actions based on what will give a higher reward, and higher reward is given by getting a high molar amount and concentraion of the desired material (in our case dodecane) in a particular vessel. Please input the following action and multipliers: Step Action Multiplier 0 0 8 1 2 10 2 0 6 3 3 10 4 1 10 5 4 10 6 5 0 while not done: action = np.zeros(env.action_space.shape[0]) for index, action_desc in enumerate(action_set): print(f'{index}: {action_desc}') print('Please enter an action and an action multiplier') for i in range(2): message = 'Action' if i == 1: message = 'Action Multiplier:' action[i] = int(input(f'{message}: ')) # perform the action and update the reward state, reward, done, __ = env.step(action) print('-----------------------------------------') print('total_steps: ', total_steps) print('reward: %.2f ' % reward) total_reward += reward print('total reward: %.2f ' % total_reward) print('Temperature of boiling vessel: %.1f ' % env.boil_vessel.temperature, ' K \\n') # print(state) # render the plot env.render(mode=render_mode) # sleep(1) #increment one step total_steps += 1","title":"Running the environment"},{"location":"lesson_1_distillation/#step-0-adding-temperature-to-the-vessel","text":"action multiplier 0 8 This will result in a temperature reaching the boiling point of water, which you will notice is now boiled off in beaker_0 (or the condensation vessel)","title":"Step 0: Adding temperature to the vessel"},{"location":"lesson_1_distillation/#step-1-pour-from-condensation-to-storage-vessel","text":"action multiplier 2 10 We can then see that storage vessel is now filled with the H2O poured from the condensation vessel. *plot not fixed yet *","title":"Step 1: Pour from condensation to storage vessel"},{"location":"lesson_1_distillation/#step-2-add-some-more-temperature","text":"action multiplier 0 6","title":"Step 2: Add some more temperature"},{"location":"lesson_1_distillation/#step-3-pouring-back-from-condensation-vessel-to-boiling-vessel","text":"action multiplier 3 10 You should see now that everything from the condensation vessel is back in the boiling vessel. ---Should insert graph here but it doesn't show the action correctly---","title":"Step 3: Pouring back from condensation vessel to boiling vessel"},{"location":"lesson_1_distillation/#step-4-pour-everything-from-boiling-vessel-into-condensation-vessel","text":"action multiplier 1 10 Notice now that all the materials are in the condensation vessel.","title":"Step 4: Pour everything from boiling vessel into condensation vessel"},{"location":"lesson_1_distillation/#step-5-pour-the-originally-boiled-off-h2o-in-the-storage-vessel-into-the-boiling-vessel","text":"action multiplier 4 10 Now you can see that the H2O which was previously in the storage vessel, is now in the boiling vessel.","title":"Step 5: Pour the originally boiled off H2O in the storage vessel into the boiling vessel"},{"location":"lesson_1_distillation/#step-6-ending-the-experiment","text":"action multiplier 5 0","title":"Step 6: Ending the experiment"},{"location":"lesson_1_distillation/#end-of-the-lesson","text":"This concludes the end of our tutorial. Hopefully you got a chance to see how the basic actions in the distillation environment works and see how you can use the agent in RL applications to maximize the distillation of a desired material. In the next tutorial we will perform 2 experiments where we heat up the boiling vessel to the maximum temperature it can reach, and vice versa where we cool it to the lowest temperature.","title":"End of the lesson"},{"location":"lesson_1_extract/","text":"Extraction Bench: Lesson 1 Using a non-polar solute to extract a solute from water In this tutorial, we am going to walk you through how our environment works and hopefully give some insight into how an RL agent might interact with the envirionment. In this extraction we are going to be using oil to extract sodium and chlorine from water. We are going to be using this file lessons/extraction_bench/oil_water.py in order to interact with the environment and to try and achieve a high reward! So start by running the lessons/extraction_bench/oil_water.py you should see a series of graphs like these appear: These graphs show the contents of each of our containers and the level of seperation between the materials. The graphs to the right then show the layers of materials forming in the container. When we start the environment we will see that we have a container filled with water, Na and Cl. The objective of this environment is to get the Na out of the water, but how might we do this? As the chemists amoung us will say this is a very simple task, and indeed it is. Using a non-polar solvent we can get the sodium and chlorine to diffuse from the water into that solvent, in this case we can use oil as our non-polar solvent! so now that the environemnt is loaded, you should see a prompt in the command line. Before we start playing around with the environment, let's take a look at the action space. For this case our action space is a matrix: {0, 1} n_action x multiplier in essence at each time step the RL agent selects from a set of actions and then in turn picks a multiplier for that action. Action: Multiplier 0: Multiplier 1: Multiplier 2: Multiplier 3: Mix beaker 1 0 1 0 0 Drain beaker 1 into 2 0 0 0 0 Pour oil into beaker 1 0 0 0 0 As an example the agent might want to pour a certain amount of solution out of our container so the row controls what action they take, and the column represents an action multiplier. So in the example of pouring out a certain amount of solution, the multiplier might control how much of the solution we pour out of our container. so our action matrix will thus be a matrix of zeroes with a single 1. In the set up of the environment we select a dT, this dT represents the period of time we take in between each action. Now that we have a better idea of our action space we can move onto testing out the environment. As stated earlier we need to use oil to extract the sodium from the water, but if we look at the graph now, we can clearly see that there is no oil in the container, so let's add some! Now that we've added the oil we need to mix the vessel to get the sodium to transfer into the oil, so let's mix the vessel! Now that we have done some mixing we need to wait for the oil to settle to the top of the water so we can drain the water. Keep repeating the following command until the graph settles. Now that the water and oil have settled we want to drain out our water into beaker 1 so that we can pour out our oil into vessel 2. Keep repeating the command the changing the multiplier as needed until the graph looks something like this: Now we pour the oil into vessel 2. Now if we want to we can pour back the water from vessel 1 into our extraction vessel and repeat the process to get a more of the sodium out of the oil. However, for an introduction this much should satisfy, now that we have finished, we want to see how well we did so now we enter the done command. We hope this tutorial helped with your understanding of how an agent might interact with the extraction environmenment!","title":"Extraction Bench Tutorial"},{"location":"lesson_1_extract/#extraction-bench-lesson-1","text":"","title":"Extraction Bench: Lesson 1"},{"location":"lesson_1_extract/#using-a-non-polar-solute-to-extract-a-solute-from-water","text":"In this tutorial, we am going to walk you through how our environment works and hopefully give some insight into how an RL agent might interact with the envirionment. In this extraction we are going to be using oil to extract sodium and chlorine from water. We are going to be using this file lessons/extraction_bench/oil_water.py in order to interact with the environment and to try and achieve a high reward! So start by running the lessons/extraction_bench/oil_water.py you should see a series of graphs like these appear: These graphs show the contents of each of our containers and the level of seperation between the materials. The graphs to the right then show the layers of materials forming in the container. When we start the environment we will see that we have a container filled with water, Na and Cl. The objective of this environment is to get the Na out of the water, but how might we do this? As the chemists amoung us will say this is a very simple task, and indeed it is. Using a non-polar solvent we can get the sodium and chlorine to diffuse from the water into that solvent, in this case we can use oil as our non-polar solvent! so now that the environemnt is loaded, you should see a prompt in the command line. Before we start playing around with the environment, let's take a look at the action space. For this case our action space is a matrix: {0, 1} n_action x multiplier in essence at each time step the RL agent selects from a set of actions and then in turn picks a multiplier for that action. Action: Multiplier 0: Multiplier 1: Multiplier 2: Multiplier 3: Mix beaker 1 0 1 0 0 Drain beaker 1 into 2 0 0 0 0 Pour oil into beaker 1 0 0 0 0 As an example the agent might want to pour a certain amount of solution out of our container so the row controls what action they take, and the column represents an action multiplier. So in the example of pouring out a certain amount of solution, the multiplier might control how much of the solution we pour out of our container. so our action matrix will thus be a matrix of zeroes with a single 1. In the set up of the environment we select a dT, this dT represents the period of time we take in between each action. Now that we have a better idea of our action space we can move onto testing out the environment. As stated earlier we need to use oil to extract the sodium from the water, but if we look at the graph now, we can clearly see that there is no oil in the container, so let's add some! Now that we've added the oil we need to mix the vessel to get the sodium to transfer into the oil, so let's mix the vessel! Now that we have done some mixing we need to wait for the oil to settle to the top of the water so we can drain the water. Keep repeating the following command until the graph settles. Now that the water and oil have settled we want to drain out our water into beaker 1 so that we can pour out our oil into vessel 2. Keep repeating the command the changing the multiplier as needed until the graph looks something like this: Now we pour the oil into vessel 2. Now if we want to we can pour back the water from vessel 1 into our extraction vessel and repeat the process to get a more of the sodium out of the oil. However, for an introduction this much should satisfy, now that we have finished, we want to see how well we did so now we enter the done command. We hope this tutorial helped with your understanding of how an agent might interact with the extraction environmenment!","title":"Using a non-polar solute to extract a solute from water"},{"location":"lesson_1_react/","text":"Reaction Bench: Lesson 1 Part 1: In this lesson I will be taking you through how our reaction bench environment works and how an RL agent might interact with the environment. The reaction bench environment is meant to as it sounds simulate a reaction, in most reaction benches the agent will have a number of reagents and the ability to play with the environmental conditions of the reaction and through doing this the agent is trying to maximize the yield of a certain desired material. For the reaction bench we use a reaction file which specifies the mechanics of a certain reaction or multiple reactions. For instance the Wurtz reaction is made up of 6 different reactions and as such is a very complicated reaction which the agent has to try and learn the mechanisms of the reaction environment it is in. For this lesson we will be using a simplified version of the wurtz reaction to introduce you to how actions affect the environment. Firtst let's load up the environment, I highly recommend you look at the source code for the reaction bench and reaction, it should help provide insight into how this all works. Further the lesson on creating a custom reaction environment will also help give insight into the reaction mechanics. In order to run the environment simply run: lessons/reaction_bench/reaction_wurtz.py . When you run this file you should see a prompt like this in your command line along with the following graph: Understanding the graph above is important to understanding how the agent will have to understand the environment. On the left we can see the absorbance spectra of the materials in our reaction vessel, and on the right we have a relative scale of a number of important metrics. From left to right we have time passed, temperature, volume (solvent) , presure, and the quantity of reagents that we have available to use. All of this data is what the RL agent has inorder for it to try and optimize the reaction pathway. The reaction we are using is as follows: 2 1-chlorohexane + 2 Na --> dodecane + 2 NaCl This reaction is performed in an aqueous state with ethoxyethane as the solvent. With all that out of the way let's focus our attention to the action space. For this reaction environemnt our action space is represented by a 6 element vector. Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na Value range: 0-1 0-1 0-1 0-1 0-1 0-1 As you might have noticed now, the reaction bench environment deals with a continuous action space. So what exactly do these continuous values represent? For the environmental conditions, in this case Volume and Temperature 0 represents a decrease in temperature or volume by dT or dV (specified in the reaction bench), 1/2 represents no change, and 1 represents an increase by dT or dV. For the chemicals, 0 represents adding no amount of that chemical to the reaction vessel, and 1 represents adding all of the originally available chemical (there is a negative reward if you try to add more chemical than is available). Now that we understand the action space I encourage you to use this reaction environment and to play around with the environmental conditions and adding the chemicals into the reaction vessel. Part 2: Here I will provide instructions on how to maximize the return of this reaction environment. This is fairly simple for this task and have thus provided some script which demonstrates our strategy, and I encourage you to try your own strategy and see how it performs. In this case cour strategy is at step 1 to increase the temperature, keep the volume of solvent constant, and to add all our reagents, in this case 1-chlorohexane and Na. This gives us an action vector of: Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 1 0 0 1 Then at every next step we are going to keep the solvent volume constant and increase the temperature Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 0 0 0 0 to see this strategy in action simply run lessons/reaction_bench/reaction_wurtz_automated.py you should see a graph like this at the end and recieve a reward of the following: and now we're done! I hope you have a better sense of how the reaction environment works and the process through which an RL agent must go through to learn the environment.","title":"Reaction Bench Tutorial, Lesson 1"},{"location":"lesson_1_react/#reaction-bench-lesson-1","text":"","title":"Reaction Bench: Lesson 1"},{"location":"lesson_1_react/#part-1","text":"In this lesson I will be taking you through how our reaction bench environment works and how an RL agent might interact with the environment. The reaction bench environment is meant to as it sounds simulate a reaction, in most reaction benches the agent will have a number of reagents and the ability to play with the environmental conditions of the reaction and through doing this the agent is trying to maximize the yield of a certain desired material. For the reaction bench we use a reaction file which specifies the mechanics of a certain reaction or multiple reactions. For instance the Wurtz reaction is made up of 6 different reactions and as such is a very complicated reaction which the agent has to try and learn the mechanisms of the reaction environment it is in. For this lesson we will be using a simplified version of the wurtz reaction to introduce you to how actions affect the environment. Firtst let's load up the environment, I highly recommend you look at the source code for the reaction bench and reaction, it should help provide insight into how this all works. Further the lesson on creating a custom reaction environment will also help give insight into the reaction mechanics. In order to run the environment simply run: lessons/reaction_bench/reaction_wurtz.py . When you run this file you should see a prompt like this in your command line along with the following graph: Understanding the graph above is important to understanding how the agent will have to understand the environment. On the left we can see the absorbance spectra of the materials in our reaction vessel, and on the right we have a relative scale of a number of important metrics. From left to right we have time passed, temperature, volume (solvent) , presure, and the quantity of reagents that we have available to use. All of this data is what the RL agent has inorder for it to try and optimize the reaction pathway. The reaction we are using is as follows: 2 1-chlorohexane + 2 Na --> dodecane + 2 NaCl This reaction is performed in an aqueous state with ethoxyethane as the solvent. With all that out of the way let's focus our attention to the action space. For this reaction environemnt our action space is represented by a 6 element vector. Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na Value range: 0-1 0-1 0-1 0-1 0-1 0-1 As you might have noticed now, the reaction bench environment deals with a continuous action space. So what exactly do these continuous values represent? For the environmental conditions, in this case Volume and Temperature 0 represents a decrease in temperature or volume by dT or dV (specified in the reaction bench), 1/2 represents no change, and 1 represents an increase by dT or dV. For the chemicals, 0 represents adding no amount of that chemical to the reaction vessel, and 1 represents adding all of the originally available chemical (there is a negative reward if you try to add more chemical than is available). Now that we understand the action space I encourage you to use this reaction environment and to play around with the environmental conditions and adding the chemicals into the reaction vessel.","title":"Part 1:"},{"location":"lesson_1_react/#part-2","text":"Here I will provide instructions on how to maximize the return of this reaction environment. This is fairly simple for this task and have thus provided some script which demonstrates our strategy, and I encourage you to try your own strategy and see how it performs. In this case cour strategy is at step 1 to increase the temperature, keep the volume of solvent constant, and to add all our reagents, in this case 1-chlorohexane and Na. This gives us an action vector of: Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 1 0 0 1 Then at every next step we are going to keep the solvent volume constant and increase the temperature Temperature Volume 1-chlorohexane 2-chlorohexane 3-chlorohexane Na 1 1/2 0 0 0 0 to see this strategy in action simply run lessons/reaction_bench/reaction_wurtz_automated.py you should see a graph like this at the end and recieve a reward of the following: and now we're done! I hope you have a better sense of how the reaction environment works and the process through which an RL agent must go through to learn the environment.","title":"Part 2:"},{"location":"lesson_2_distillation/","text":"Distillation Bench: Lesson 2 This experiment consists of 3 main parts. We will: - Increase to the maximum temperature with a multiplier of 6 - Increase to the maximum temperature with a multiplier of 7 - Decrease to the minimum temperature with a multiplier of 3 We will see how these actions play out in the distillation bench environment and gain more intuition into how the distillation bench works. First let's start by importing all the required modules. # import all the required external modules import gym import numpy as np import os import pickle import sys from time import sleep from gym import envs import matplotlib.pyplot as plt import pandas as pd # ensure all necessary modules can be found sys.path.append(\"../\") # to access chemistrylab sys.path.append(\"../chemistrylab/reactions\") # to access all reactions # import all local modules import chemistrylab # show all environments for distillation bench all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Distillation' in env_spec.id] print(env_ids) ['Distillation-v0'] You'll notice that the setup is the same as in lesson 1. Nothing changes for the initialization in this project. The main difference is in the loop later. # allows user to pick which environment they want to use # initializes environment select_env = int(input(f\"Enter a number to choose which environment you want to run (0 - {len(env_ids) - 1}): \\n\")) env = gym.make(env_ids[select_env]) render_mode = \"human\" Enter a number to choose which environment you want to run (0 - 0): 0 done = False __ = env.reset() print('\\n') action[0] 0 Add/Remove Heat (Heat Value multiplier, relative of maximal heat change) 1 Pour BV into B1 (Volume multiplier, relative to max_vessel_volume) 2 Pour B1 into B2 (Volume multiplier, relative to max_vessel_volume) 3 Pour B1 into BV (Volume multiplier, relative to max_vessel_volume) 4 Pour B2 into BV (Volume multiplier, relative to max_vessel_volume) 5 Done (Value doesn't matter) action_set = ['Add/Remove Heat', 'Pour BV into B1', 'Pour B1 into B2', 'Pour B1 into BV', 'Pour B2 into BV', 'Done'] assert env.action_space.shape[0] == 2 total_steps=0 total_reward=0 Here we see that there are 3 main actions, where 2 are commented out. Based on which part of the lesson you're on, please uncomment the needed action. Action Array Significance Increasing the temperature all the way up with a multiplier of 6 [0,6] This will allow us to increase the temperature to the maximum amount without resulting in all the materials being boiled off in the vessel. Increasing the temperature all the way uo with a multiplier of 7 [0,7] This will increase the temperature to the maximum amount however all the materials will boil off resulting in an error. Decrease the temperature down [0,3] Shows that there is a minimum temperature for the boiling vessel and that it will not go below this temperature. while not done: # ACTION 1 # increase temperature all the way up action = np.array([0,6]) # ACTION 2 # results in temperature being too high and all material is boiled off in the vessel # action = np.array([0,7]) # ACTION 3 # decrease temperature all the way down # action = np.array([0,3]) # perform the action and update the reward state, reward, done, __ = env.step(action) print('-----------------------------------------') print('total_steps: ', total_steps) print('reward: %.2f ' % reward) total_reward += reward print('total reward: %.2f' % total_reward) print(action) print('Temperature of boiling vessel: %.1f ' % env.boil_vessel.temperature, ' K \\n') # print(state) # render the plot env.render(mode=render_mode) # sleep(1) multiplier = 2 * (6 / 10 - 0.5) print(multiplier * 1) print(env.boil_vessel.temperature) print('hello: ', env.distillation.dQ) print('hi: ', env.distillation.n_increments) #increment one step total_steps += 1 Let's try increasing the temperature of the boiling vessel (ACTION 1) # ACTION 1 # increase temperature all the way up action = np.array([0,6]) When we run this code we should see that for every timestep that there is a heat change of 19999.99 joules and that the temperature eventually reaches 1738.0 Kelvin. We end up with a final graph that looks like this: As you can see all the material is boiled off from the boiling vessel into the condensation vessel. Again the graphs are showing the wrong values Increasing the temperature with a higher multiplier (ACTION 2) # ACTION 2 # results in temperature being too high and all material is boiled off in the vessel action = np.array([0,7]) For this we will uncomment action 2. Now running this code gives us an interesting result. Run it yourself to see that we will get: We get this error as since we increased the temperature by a higher multiplier we were able to boil off all the materials in the boiling vessel before letting the agent finish after 20 steps. It's important to note that choosing a very large multiplier can result in this error. Still need to fix this error Lower the temperature (ACTION 3) # ACTION 3 # decrease temperature all the way down action = np.array([0,3]) We will now lower the temperature the absolute minimum it can be and see what happens. Running this results in the following graph: As you will notice, nothing really changes. Of course this isn't much of a surprise since by lowering the temperature none of the materials in the boiling vessel will boil into the condensation vessel (in this case; if you have materials with lower boiling points this will change). You'll notice that the minimum temperature the boiling vessel will reach is 297 Kelvin. This concludes a fairly simple tutorial, to once again, get an intuition of how the distillation bench works. Hopefully you can see the functionality of the environment. In the next lessons we will see how to achieve a high reward by trying to isolate a target material, in this case, dodecane, into the condensation vessel.","title":"Distillation Bench Tutorial, Lesson 2"},{"location":"lesson_2_distillation/#distillation-bench-lesson-2","text":"This experiment consists of 3 main parts. We will: - Increase to the maximum temperature with a multiplier of 6 - Increase to the maximum temperature with a multiplier of 7 - Decrease to the minimum temperature with a multiplier of 3 We will see how these actions play out in the distillation bench environment and gain more intuition into how the distillation bench works. First let's start by importing all the required modules. # import all the required external modules import gym import numpy as np import os import pickle import sys from time import sleep from gym import envs import matplotlib.pyplot as plt import pandas as pd # ensure all necessary modules can be found sys.path.append(\"../\") # to access chemistrylab sys.path.append(\"../chemistrylab/reactions\") # to access all reactions # import all local modules import chemistrylab # show all environments for distillation bench all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'Distillation' in env_spec.id] print(env_ids) ['Distillation-v0'] You'll notice that the setup is the same as in lesson 1. Nothing changes for the initialization in this project. The main difference is in the loop later. # allows user to pick which environment they want to use # initializes environment select_env = int(input(f\"Enter a number to choose which environment you want to run (0 - {len(env_ids) - 1}): \\n\")) env = gym.make(env_ids[select_env]) render_mode = \"human\" Enter a number to choose which environment you want to run (0 - 0): 0 done = False __ = env.reset() print('\\n') action[0] 0 Add/Remove Heat (Heat Value multiplier, relative of maximal heat change) 1 Pour BV into B1 (Volume multiplier, relative to max_vessel_volume) 2 Pour B1 into B2 (Volume multiplier, relative to max_vessel_volume) 3 Pour B1 into BV (Volume multiplier, relative to max_vessel_volume) 4 Pour B2 into BV (Volume multiplier, relative to max_vessel_volume) 5 Done (Value doesn't matter) action_set = ['Add/Remove Heat', 'Pour BV into B1', 'Pour B1 into B2', 'Pour B1 into BV', 'Pour B2 into BV', 'Done'] assert env.action_space.shape[0] == 2 total_steps=0 total_reward=0 Here we see that there are 3 main actions, where 2 are commented out. Based on which part of the lesson you're on, please uncomment the needed action. Action Array Significance Increasing the temperature all the way up with a multiplier of 6 [0,6] This will allow us to increase the temperature to the maximum amount without resulting in all the materials being boiled off in the vessel. Increasing the temperature all the way uo with a multiplier of 7 [0,7] This will increase the temperature to the maximum amount however all the materials will boil off resulting in an error. Decrease the temperature down [0,3] Shows that there is a minimum temperature for the boiling vessel and that it will not go below this temperature. while not done: # ACTION 1 # increase temperature all the way up action = np.array([0,6]) # ACTION 2 # results in temperature being too high and all material is boiled off in the vessel # action = np.array([0,7]) # ACTION 3 # decrease temperature all the way down # action = np.array([0,3]) # perform the action and update the reward state, reward, done, __ = env.step(action) print('-----------------------------------------') print('total_steps: ', total_steps) print('reward: %.2f ' % reward) total_reward += reward print('total reward: %.2f' % total_reward) print(action) print('Temperature of boiling vessel: %.1f ' % env.boil_vessel.temperature, ' K \\n') # print(state) # render the plot env.render(mode=render_mode) # sleep(1) multiplier = 2 * (6 / 10 - 0.5) print(multiplier * 1) print(env.boil_vessel.temperature) print('hello: ', env.distillation.dQ) print('hi: ', env.distillation.n_increments) #increment one step total_steps += 1","title":"Distillation Bench: Lesson 2"},{"location":"lesson_2_distillation/#lets-try-increasing-the-temperature-of-the-boiling-vessel-action-1","text":"# ACTION 1 # increase temperature all the way up action = np.array([0,6]) When we run this code we should see that for every timestep that there is a heat change of 19999.99 joules and that the temperature eventually reaches 1738.0 Kelvin. We end up with a final graph that looks like this: As you can see all the material is boiled off from the boiling vessel into the condensation vessel. Again the graphs are showing the wrong values","title":"Let's try increasing the temperature of the boiling vessel (ACTION 1)"},{"location":"lesson_2_distillation/#increasing-the-temperature-with-a-higher-multiplier-action-2","text":"# ACTION 2 # results in temperature being too high and all material is boiled off in the vessel action = np.array([0,7]) For this we will uncomment action 2. Now running this code gives us an interesting result. Run it yourself to see that we will get: We get this error as since we increased the temperature by a higher multiplier we were able to boil off all the materials in the boiling vessel before letting the agent finish after 20 steps. It's important to note that choosing a very large multiplier can result in this error. Still need to fix this error","title":"Increasing the temperature with a higher multiplier (ACTION 2)"},{"location":"lesson_2_distillation/#lower-the-temperature-action-3","text":"# ACTION 3 # decrease temperature all the way down action = np.array([0,3]) We will now lower the temperature the absolute minimum it can be and see what happens. Running this results in the following graph: As you will notice, nothing really changes. Of course this isn't much of a surprise since by lowering the temperature none of the materials in the boiling vessel will boil into the condensation vessel (in this case; if you have materials with lower boiling points this will change). You'll notice that the minimum temperature the boiling vessel will reach is 297 Kelvin. This concludes a fairly simple tutorial, to once again, get an intuition of how the distillation bench works. Hopefully you can see the functionality of the environment. In the next lessons we will see how to achieve a high reward by trying to isolate a target material, in this case, dodecane, into the condensation vessel.","title":"Lower the temperature (ACTION 3)"},{"location":"lesson_2_reaction/","text":"Reaction Bench Lesson 2 Getting a high reward in a reaction of form: A-X + A-X --> A-A + X-X and A-X + B-X --> A-B + X-X In this lesson we will try to get a high reward in the reaction of the form above. Rewards will come from producing either A-A or B-B. It's important to note that the reward cannot come from A-B as this doesn't make the desired property. The reaction we will be simulating in this lesson is specifically: - 2 3-chlorohexane + 2 Na --> 4,5-diethyloctane + 2 NaCl In similar fashion to lesson 1, the reactions used in this lesson are found in the reaction file. The reaction above is 1 of the 6 total reactions in the Wurtz reaction. The particular reaction we will be simulating is performed in an aqueous state with ethoxyethane as the solvent. From lesson 1 we know that our action space is a 6 element vector represented by: Temperature Volume 1-chlorohexane 2 chlorohexane 3-chlorohexane Na Value range: 0-1 0-1 0-1 0-1 0-1 0-1 Each index corresponds to the following label and how we change them. For example is action[0] = 0 then the temperature will decrease. If it is set to 0.5 then it will stay the same and if set to 1 then the temperature will increase. First let's start by importing all the modules we need. # import all the required external modules import gym import numpy as np import os import pickle import sys from time import sleep from gym import envs import matplotlib.pyplot as plt import pandas as pd %matplotlib inline # ensure all necessary modules can be found sys.path.append(\"../\") # to access chemistrylab sys.path.append(\"../chemistrylab/reactions\") # to access all reactions # import all local modules import chemistrylab This will show all the environments we can currently run. Eventually you can create your own environments with different reactions and target material using the reaction template. # show all environments for reaction bench all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'React' in env_spec.id] print(env_ids) ['WurtzReact-v0', 'WurtzReact_overlap-v0'] This explains the simulated reaction we are trying to simulate and is initializing the reaction environment. # trying to get high reward for wurtz reaction of form: # A-X + A-X --> A-A + X-X and A-X + B-X --> A-B + X-X # Rewards comes from producing A-A or B-B # Cannot come from A-B as this doesn't make the desired property # Desired material in this case is initialized to be 4,5-diethyloctane # initializes environment env = gym.make(\"WurtzReact-v0\") render_mode = \"human\" done = False __ = env.reset() # shows # of actions available print('# of actions available: ',env.action_space.shape[0]) num_actions_available = env.action_space.shape[0] total_steps=0 total_reward=0 # of actions available: 6 We will store certain values in these arrays so can plot them later on to visually show how each variable changes over time. reward_over_time=[] steps_over_time=[] reactant_1 = [] reactant_2 = [] total_reward_over_time = [] action = np.ones(env.action_space.shape) The key to achieving a high reward in this simulation is to only add the reactants that are needed for the reaction to continue. This means that we will only add 3-chlorohexane and Na with our actions. This will allow us to maximize our reward as a large quantity of these reactants means the reaction with our target material will occur more often. We do this by running the following commands: if total_steps < 20: action[0] = 1 action[1] = 1 action[2] = 0.05 # 1-chlorohexane action[3] = 0.05 # 2-chlorohexane action[4] = 1 # 3-chlorohexane action[5] = 1 # Na Notice that we're only adding the reactants we need for the reaction to continue. Let's run our program and see what happens! while not done: # Actions: # a[0] changes the temperature between -dT (a[0] = 0.0) and +dT (a[0] = 1.0) # a[1] changes the Volume between -dV (a[1] = 0.0) and +dV (a[1] = 1.0) # a[2:] adds between none (a[2:] = 0.0) and all (a[2:] = 1.0) of each reactant if total_steps < 20: action[0] = 1 action[1] = 1 action[2] = 0.05 # 1-chlorohexane action[3] = 0.05 # 2-chlorohexane action[4] = 1 # 3-chlorohexane action[5] = 1 # Na ''' # Adding Reactants not needed: action[0] = 1 action[1] = 1 action[5] = 1 action[4] = 1 action[2] = 1 action[3] = 1 ''' # perform the action and update the reward state, reward, done, __ = env.step(action) print('-----------------------------------------') print('total_steps: ', total_steps) print('reward: %.2f ' % reward) total_reward += reward print('total reward: %.2f' % total_reward) # print(state) # render the plot env.render(mode=render_mode) # sleep(2) # increment one step total_steps += 1 # append arrays for states over time reward_over_time.append(reward) total_reward_over_time.append(total_reward) steps_over_time.append(total_steps) reactant_1.append(env.state[6]) reactant_2.append(env.state[7]) ----------------------------------------- total_steps: 0 reward: 0.28 total reward: 0.28 ----------------------------------------- total_steps: 1 reward: 0.28 total reward: 0.57 ----------------------------------------- total_steps: 2 reward: 0.28 total reward: 0.85 ----------------------------------------- total_steps: 3 reward: 0.28 total reward: 1.13 ----------------------------------------- total_steps: 4 reward: 0.28 total reward: 1.41 ----------------------------------------- total_steps: 5 reward: 0.28 total reward: 1.69 ----------------------------------------- total_steps: 6 reward: 0.28 total reward: 1.97 ----------------------------------------- total_steps: 7 reward: 0.28 total reward: 2.25 ----------------------------------------- total_steps: 8 reward: 0.28 total reward: 2.52 ----------------------------------------- total_steps: 9 reward: 0.28 total reward: 2.80 ----------------------------------------- total_steps: 10 reward: 0.28 total reward: 3.08 ----------------------------------------- total_steps: 11 reward: 0.28 total reward: 3.35 ----------------------------------------- total_steps: 12 reward: 0.27 total reward: 3.63 ----------------------------------------- total_steps: 13 reward: 0.26 total reward: 3.89 ----------------------------------------- total_steps: 14 reward: 0.26 total reward: 4.14 ----------------------------------------- total_steps: 15 reward: 0.25 total reward: 4.39 ----------------------------------------- total_steps: 16 reward: 0.24 total reward: 4.63 ----------------------------------------- total_steps: 17 reward: 0.24 total reward: 4.87 ----------------------------------------- total_steps: 18 reward: 0.23 total reward: 5.10 ----------------------------------------- total_steps: 19 reward: 0.23 total reward: 5.33 Notice that we get a total reward of 5.33. A visual representation of the reactants being used and total reward increasing can be seen in the subplot we produce! This simply shows us the stats of the reaction vessel. It essentially shows everything from thermodynamic variables, to the amount of material # ask user if they want to see stats of reaction vessel show_stats = input(\"Show Reaction Vessel Stats ('Y'/'N') >>> \") if show_stats.lower() in [\"y\", \"yes\"]: # open and check the material dict vessel_path = os.path.join(os.getcwd(), \"vessel_experiment_0.pickle\") with open(vessel_path, 'rb') as open_file: v = pickle.load(open_file) print(\"\") print(\"---------- VESSEL ----------\") print(\"Label: {}\".format(v.label)) print(\"\") print(\"---------- THERMODYNAMIC VARIABLES ----------\") print(\"Temperature (in K): {:e}\".format(v.temperature)) print(\"Volume (in L): {:e}\".format(v.volume)) print(\"Pressure (in kPa): {:e}\".format(v.pressure)) print(\"\") print(\"---------- MATERIAL_DICT ----------\") for material, value_list in v._material_dict.items(): print(\"{} : {}\".format(material, value_list)) print(\"\") print(\"---------- SOLUTE_DICT ----------\") for solute, value_list in v._solute_dict.items(): print(\"{} : {}\".format(solute, value_list)) Show Reaction Vessel Stats ('Y'/'N') >>> y ---------- VESSEL ---------- Label: new ---------- THERMODYNAMIC VARIABLES ---------- Temperature (in K): 1.000000e+00 Volume (in L): 1.197500e-06 Pressure (in kPa): 8.192200e-07 ---------- MATERIAL_DICT ---------- 1-chlorohexane : [<class 'chemistrylab.chem_algorithms.material.OneChlorohexane'>, 0.2768946] 2-chlorohexane : [<class 'chemistrylab.chem_algorithms.material.TwoChlorohexane'>, 0.0] 3-chlorohexane : [<class 'chemistrylab.chem_algorithms.material.ThreeChlorohexane'>, 0.0] Na : [<class 'chemistrylab.chem_algorithms.material.Na'>, 0.2768946] dodecane : [<class 'chemistrylab.chem_algorithms.material.Dodecane'>, 0.36155286] 5-methylundecane : [<class 'chemistrylab.chem_algorithms.material.FiveMethylundecane'>, 0.0] 4-ethyldecane : [<class 'chemistrylab.chem_algorithms.material.FourEthyldecane'>, 0.0] 5,6-dimethyldecane : [<class 'chemistrylab.chem_algorithms.material.FiveSixDimethyldecane'>, 0.0] 4-ethyl-5-methylnonane : [<class 'chemistrylab.chem_algorithms.material.FourEthylFiveMethylnonane'>, 0.0] 4,5-diethyloctane : [<class 'chemistrylab.chem_algorithms.material.FourFiveDiethyloctane'>, 0.0] NaCl : [<class 'chemistrylab.chem_algorithms.material.NaCl'>, 0.7231057] ---------- SOLUTE_DICT ---------- ethoxyethane : [<class 'chemistrylab.chem_algorithms.material.Ethoxyethane'>, 1.0] Why 4,5-diethyloctane is not in the vessel stats???? # graph states over time fig, (ax1, ax2, ax3, ax4) = plt.subplots(4) ax1.plot(steps_over_time, reactant_1) ax1.set_title('Steps vs. Reactant 1 (3-chlorohexane)') ax1.set_xlabel('Steps') ax1.set_ylabel('3-chlorohexane') ax2.plot(steps_over_time, reactant_2, 'tab:orange') ax2.set_title('Steps vs. Reactant 2 (Na)') ax2.set_xlabel('Steps') ax2.set_ylabel('Na') ax3.plot(steps_over_time, reward_over_time, 'tab:green') ax3.set_title('Steps vs Reward') ax3.set_xlabel('Steps') ax3.set_ylabel('Reward') ax4.plot(steps_over_time, total_reward_over_time, 'tab:red') ax4.set_title('Steps vs Total Reward') ax4.set_xlabel('Steps') ax4.set_ylabel('Total Reward') fig.tight_layout() plt.savefig('Final Subplots Demo Lesson 3.png') plt.show() For the second part of the experiment let's uncomment the code that adds the reactants not needed and run our code again. Note that this is still the same simulation of the reaction stated at the start. We are just changing the reactants that we're adding. # Adding Reactants not needed: action[0] = 1 action[1] = 1 action[5] = 1 action[4] = 1 action[2] = 1 action[3] = 1 If we run this code we'll notice that our reward is significantly lower. It is now only 0.63 which is a drop-off from our previous set of actions. Once again, the reason this is happening is that other reactions are taking place instead of the reaction that produces our desired material. The next step for this reaction environment is to write an RL implementation that will allow the agent to solve this problem for you essentially maximizing our output of the desired material!","title":"Reaction Bench Tutorial, Lesson 2"},{"location":"lesson_2_reaction/#reaction-bench-lesson-2","text":"","title":"Reaction Bench Lesson 2"},{"location":"lesson_2_reaction/#getting-a-high-reward-in-a-reaction-of-form","text":"","title":"Getting a high reward in a reaction of form:"},{"location":"lesson_2_reaction/#a-x-a-x-a-a-x-x-and-a-x-b-x-a-b-x-x","text":"In this lesson we will try to get a high reward in the reaction of the form above. Rewards will come from producing either A-A or B-B. It's important to note that the reward cannot come from A-B as this doesn't make the desired property. The reaction we will be simulating in this lesson is specifically: - 2 3-chlorohexane + 2 Na --> 4,5-diethyloctane + 2 NaCl In similar fashion to lesson 1, the reactions used in this lesson are found in the reaction file. The reaction above is 1 of the 6 total reactions in the Wurtz reaction. The particular reaction we will be simulating is performed in an aqueous state with ethoxyethane as the solvent. From lesson 1 we know that our action space is a 6 element vector represented by: Temperature Volume 1-chlorohexane 2 chlorohexane 3-chlorohexane Na Value range: 0-1 0-1 0-1 0-1 0-1 0-1 Each index corresponds to the following label and how we change them. For example is action[0] = 0 then the temperature will decrease. If it is set to 0.5 then it will stay the same and if set to 1 then the temperature will increase. First let's start by importing all the modules we need. # import all the required external modules import gym import numpy as np import os import pickle import sys from time import sleep from gym import envs import matplotlib.pyplot as plt import pandas as pd %matplotlib inline # ensure all necessary modules can be found sys.path.append(\"../\") # to access chemistrylab sys.path.append(\"../chemistrylab/reactions\") # to access all reactions # import all local modules import chemistrylab This will show all the environments we can currently run. Eventually you can create your own environments with different reactions and target material using the reaction template. # show all environments for reaction bench all_envs = envs.registry.all() env_ids = [env_spec.id for env_spec in all_envs if 'React' in env_spec.id] print(env_ids) ['WurtzReact-v0', 'WurtzReact_overlap-v0'] This explains the simulated reaction we are trying to simulate and is initializing the reaction environment. # trying to get high reward for wurtz reaction of form: # A-X + A-X --> A-A + X-X and A-X + B-X --> A-B + X-X # Rewards comes from producing A-A or B-B # Cannot come from A-B as this doesn't make the desired property # Desired material in this case is initialized to be 4,5-diethyloctane # initializes environment env = gym.make(\"WurtzReact-v0\") render_mode = \"human\" done = False __ = env.reset() # shows # of actions available print('# of actions available: ',env.action_space.shape[0]) num_actions_available = env.action_space.shape[0] total_steps=0 total_reward=0 # of actions available: 6 We will store certain values in these arrays so can plot them later on to visually show how each variable changes over time. reward_over_time=[] steps_over_time=[] reactant_1 = [] reactant_2 = [] total_reward_over_time = [] action = np.ones(env.action_space.shape) The key to achieving a high reward in this simulation is to only add the reactants that are needed for the reaction to continue. This means that we will only add 3-chlorohexane and Na with our actions. This will allow us to maximize our reward as a large quantity of these reactants means the reaction with our target material will occur more often. We do this by running the following commands: if total_steps < 20: action[0] = 1 action[1] = 1 action[2] = 0.05 # 1-chlorohexane action[3] = 0.05 # 2-chlorohexane action[4] = 1 # 3-chlorohexane action[5] = 1 # Na Notice that we're only adding the reactants we need for the reaction to continue. Let's run our program and see what happens! while not done: # Actions: # a[0] changes the temperature between -dT (a[0] = 0.0) and +dT (a[0] = 1.0) # a[1] changes the Volume between -dV (a[1] = 0.0) and +dV (a[1] = 1.0) # a[2:] adds between none (a[2:] = 0.0) and all (a[2:] = 1.0) of each reactant if total_steps < 20: action[0] = 1 action[1] = 1 action[2] = 0.05 # 1-chlorohexane action[3] = 0.05 # 2-chlorohexane action[4] = 1 # 3-chlorohexane action[5] = 1 # Na ''' # Adding Reactants not needed: action[0] = 1 action[1] = 1 action[5] = 1 action[4] = 1 action[2] = 1 action[3] = 1 ''' # perform the action and update the reward state, reward, done, __ = env.step(action) print('-----------------------------------------') print('total_steps: ', total_steps) print('reward: %.2f ' % reward) total_reward += reward print('total reward: %.2f' % total_reward) # print(state) # render the plot env.render(mode=render_mode) # sleep(2) # increment one step total_steps += 1 # append arrays for states over time reward_over_time.append(reward) total_reward_over_time.append(total_reward) steps_over_time.append(total_steps) reactant_1.append(env.state[6]) reactant_2.append(env.state[7]) ----------------------------------------- total_steps: 0 reward: 0.28 total reward: 0.28 ----------------------------------------- total_steps: 1 reward: 0.28 total reward: 0.57 ----------------------------------------- total_steps: 2 reward: 0.28 total reward: 0.85 ----------------------------------------- total_steps: 3 reward: 0.28 total reward: 1.13 ----------------------------------------- total_steps: 4 reward: 0.28 total reward: 1.41 ----------------------------------------- total_steps: 5 reward: 0.28 total reward: 1.69 ----------------------------------------- total_steps: 6 reward: 0.28 total reward: 1.97 ----------------------------------------- total_steps: 7 reward: 0.28 total reward: 2.25 ----------------------------------------- total_steps: 8 reward: 0.28 total reward: 2.52 ----------------------------------------- total_steps: 9 reward: 0.28 total reward: 2.80 ----------------------------------------- total_steps: 10 reward: 0.28 total reward: 3.08 ----------------------------------------- total_steps: 11 reward: 0.28 total reward: 3.35 ----------------------------------------- total_steps: 12 reward: 0.27 total reward: 3.63 ----------------------------------------- total_steps: 13 reward: 0.26 total reward: 3.89 ----------------------------------------- total_steps: 14 reward: 0.26 total reward: 4.14 ----------------------------------------- total_steps: 15 reward: 0.25 total reward: 4.39 ----------------------------------------- total_steps: 16 reward: 0.24 total reward: 4.63 ----------------------------------------- total_steps: 17 reward: 0.24 total reward: 4.87 ----------------------------------------- total_steps: 18 reward: 0.23 total reward: 5.10 ----------------------------------------- total_steps: 19 reward: 0.23 total reward: 5.33 Notice that we get a total reward of 5.33. A visual representation of the reactants being used and total reward increasing can be seen in the subplot we produce! This simply shows us the stats of the reaction vessel. It essentially shows everything from thermodynamic variables, to the amount of material # ask user if they want to see stats of reaction vessel show_stats = input(\"Show Reaction Vessel Stats ('Y'/'N') >>> \") if show_stats.lower() in [\"y\", \"yes\"]: # open and check the material dict vessel_path = os.path.join(os.getcwd(), \"vessel_experiment_0.pickle\") with open(vessel_path, 'rb') as open_file: v = pickle.load(open_file) print(\"\") print(\"---------- VESSEL ----------\") print(\"Label: {}\".format(v.label)) print(\"\") print(\"---------- THERMODYNAMIC VARIABLES ----------\") print(\"Temperature (in K): {:e}\".format(v.temperature)) print(\"Volume (in L): {:e}\".format(v.volume)) print(\"Pressure (in kPa): {:e}\".format(v.pressure)) print(\"\") print(\"---------- MATERIAL_DICT ----------\") for material, value_list in v._material_dict.items(): print(\"{} : {}\".format(material, value_list)) print(\"\") print(\"---------- SOLUTE_DICT ----------\") for solute, value_list in v._solute_dict.items(): print(\"{} : {}\".format(solute, value_list)) Show Reaction Vessel Stats ('Y'/'N') >>> y ---------- VESSEL ---------- Label: new ---------- THERMODYNAMIC VARIABLES ---------- Temperature (in K): 1.000000e+00 Volume (in L): 1.197500e-06 Pressure (in kPa): 8.192200e-07 ---------- MATERIAL_DICT ---------- 1-chlorohexane : [<class 'chemistrylab.chem_algorithms.material.OneChlorohexane'>, 0.2768946] 2-chlorohexane : [<class 'chemistrylab.chem_algorithms.material.TwoChlorohexane'>, 0.0] 3-chlorohexane : [<class 'chemistrylab.chem_algorithms.material.ThreeChlorohexane'>, 0.0] Na : [<class 'chemistrylab.chem_algorithms.material.Na'>, 0.2768946] dodecane : [<class 'chemistrylab.chem_algorithms.material.Dodecane'>, 0.36155286] 5-methylundecane : [<class 'chemistrylab.chem_algorithms.material.FiveMethylundecane'>, 0.0] 4-ethyldecane : [<class 'chemistrylab.chem_algorithms.material.FourEthyldecane'>, 0.0] 5,6-dimethyldecane : [<class 'chemistrylab.chem_algorithms.material.FiveSixDimethyldecane'>, 0.0] 4-ethyl-5-methylnonane : [<class 'chemistrylab.chem_algorithms.material.FourEthylFiveMethylnonane'>, 0.0] 4,5-diethyloctane : [<class 'chemistrylab.chem_algorithms.material.FourFiveDiethyloctane'>, 0.0] NaCl : [<class 'chemistrylab.chem_algorithms.material.NaCl'>, 0.7231057] ---------- SOLUTE_DICT ---------- ethoxyethane : [<class 'chemistrylab.chem_algorithms.material.Ethoxyethane'>, 1.0] Why 4,5-diethyloctane is not in the vessel stats???? # graph states over time fig, (ax1, ax2, ax3, ax4) = plt.subplots(4) ax1.plot(steps_over_time, reactant_1) ax1.set_title('Steps vs. Reactant 1 (3-chlorohexane)') ax1.set_xlabel('Steps') ax1.set_ylabel('3-chlorohexane') ax2.plot(steps_over_time, reactant_2, 'tab:orange') ax2.set_title('Steps vs. Reactant 2 (Na)') ax2.set_xlabel('Steps') ax2.set_ylabel('Na') ax3.plot(steps_over_time, reward_over_time, 'tab:green') ax3.set_title('Steps vs Reward') ax3.set_xlabel('Steps') ax3.set_ylabel('Reward') ax4.plot(steps_over_time, total_reward_over_time, 'tab:red') ax4.set_title('Steps vs Total Reward') ax4.set_xlabel('Steps') ax4.set_ylabel('Total Reward') fig.tight_layout() plt.savefig('Final Subplots Demo Lesson 3.png') plt.show() For the second part of the experiment let's uncomment the code that adds the reactants not needed and run our code again. Note that this is still the same simulation of the reaction stated at the start. We are just changing the reactants that we're adding. # Adding Reactants not needed: action[0] = 1 action[1] = 1 action[5] = 1 action[4] = 1 action[2] = 1 action[3] = 1 If we run this code we'll notice that our reward is significantly lower. It is now only 0.63 which is a drop-off from our previous set of actions. Once again, the reason this is happening is that other reactions are taking place instead of the reaction that produces our desired material. The next step for this reaction environment is to write an RL implementation that will allow the agent to solve this problem for you essentially maximizing our output of the desired material!","title":"A-X + A-X --&gt; A-A + X-X and A-X + B-X --&gt; A-B + X-X"},{"location":"vessel_lesson/","text":"Vessel: Lesson Overview: In this lesson, we will be going through a class that is vital to the operation of all of our benches, the vessel class. The source code for this can be found here: chemistrylab/chem_algorithms/vessel.py . The vessel calss as it is named is meant to simulate the use of any given you might find in a chemistry lad, such as a beaker or an extraction vessel. Here we will be going through the important concepts, functions and attributes that make up the vessel class so that you can easily use it when designing your own reactions. If you want a more detailed look into each function of the vessel I suggest you go to our documentation on the data structure. Important Variables Structure Description _material_dict {'material.name': [material(), amount], ...} a dictionary holding all the material inside this vessel _solute_dict {'solute.name': {solvent.name: amount, ...}, ...} dictionary that represents the solution _event_dict {'function name': function} a dictionary holds the event functions of a vessel _event_queue [['event', parameters], ['event', parameters] ... ] a queue of events to be performed by vessel _feedback_queue [['event', parameters], ['event', parameters] ... ] a queue holding collected feedback from materials and unfinished events An example of _material_dict and _solute_dict (vessel with Na and Cl dissolved in H2O and C6H14) H2O = material.H2O() C6H14 = material.C6H14() Na = material.Na() Cl = material.Cl() Na.set_charge(1.0) Na.set_solute_flag(True) Cl.set_charge(-1.0) Cl.set_solute_flag(True) material_dict = {'H2O': [H2O, 100], 'C6H14': [C6H14, 100], 'Na': [Na, 1.0], 'Cl': [Cl, 1.0]} solute_dict = {'Na': {'H2O': 0.5, 'C6H14': 0.5}, 'Cl': {'H2O': 0.5, 'C6H14': 0.5}} Important functions Description push_event_to_queue() used to pass event into the vessel _update_materials() automatically called by push_event_to_queue(), execute events in _event_queue and _feedback_queue _merge_event_queue() merge the feedback_queue passed in, and all the default events (switches) are appended to _feedback_queue by this function The Workflow Agent choose action from the action space of an environment. The environment does the calculation and update and generate events. At the end of each action, if the action affect a vessel, use push_event_to_queue() to push the event into the vessel, if no event generated, call the function with events=None. With push_event_to_queue() called, events are pushed into the vessel. _update_materials is automatically called and perform events in the events_queue. Each event has a corresponding event function, it first update properties of the vessel, then loop over the materials inside the vessel by calling the corresponding event functions of each material. The materials' event function will return feedback by calling the push_event_to_queue(), which contains feedback and unfinished event The returned feedback is added to the _feedback_queue The the _merge_event_queue() is called on _feedback_queue, which merge the events in the feedback_queue to generate a merged_queue and add default event into it, then empty the _feedback_queue Then the merged_queue will be executed and new feedback are collected and added to _feedback_queue, which will be executed with the next action. Event Functions Function Name Description 'pour by volume' Pour from self vessel to target vessel by certain volume 'drain by pixel Drain from self vessel to target vessel by certain pixel 'fully mix' Shake self vessel to fully mix 'update material dict' Use input to update self vessel's material_dict 'update solute dict' Use input to update self vessel's solute_dict 'mix' Shake vessel of let vessel settle 'update_layer' Update self vessel's layer representation","title":"Vessel Lesson"},{"location":"vessel_lesson/#vessel-lesson","text":"","title":"Vessel: Lesson"},{"location":"vessel_lesson/#overview","text":"In this lesson, we will be going through a class that is vital to the operation of all of our benches, the vessel class. The source code for this can be found here: chemistrylab/chem_algorithms/vessel.py . The vessel calss as it is named is meant to simulate the use of any given you might find in a chemistry lad, such as a beaker or an extraction vessel. Here we will be going through the important concepts, functions and attributes that make up the vessel class so that you can easily use it when designing your own reactions. If you want a more detailed look into each function of the vessel I suggest you go to our documentation on the data structure. Important Variables Structure Description _material_dict {'material.name': [material(), amount], ...} a dictionary holding all the material inside this vessel _solute_dict {'solute.name': {solvent.name: amount, ...}, ...} dictionary that represents the solution _event_dict {'function name': function} a dictionary holds the event functions of a vessel _event_queue [['event', parameters], ['event', parameters] ... ] a queue of events to be performed by vessel _feedback_queue [['event', parameters], ['event', parameters] ... ] a queue holding collected feedback from materials and unfinished events","title":"Overview:"},{"location":"vessel_lesson/#an-example-of-_material_dict-and-_solute_dict","text":"(vessel with Na and Cl dissolved in H2O and C6H14) H2O = material.H2O() C6H14 = material.C6H14() Na = material.Na() Cl = material.Cl() Na.set_charge(1.0) Na.set_solute_flag(True) Cl.set_charge(-1.0) Cl.set_solute_flag(True) material_dict = {'H2O': [H2O, 100], 'C6H14': [C6H14, 100], 'Na': [Na, 1.0], 'Cl': [Cl, 1.0]} solute_dict = {'Na': {'H2O': 0.5, 'C6H14': 0.5}, 'Cl': {'H2O': 0.5, 'C6H14': 0.5}} Important functions Description push_event_to_queue() used to pass event into the vessel _update_materials() automatically called by push_event_to_queue(), execute events in _event_queue and _feedback_queue _merge_event_queue() merge the feedback_queue passed in, and all the default events (switches) are appended to _feedback_queue by this function","title":"An example of _material_dict and _solute_dict"},{"location":"vessel_lesson/#the-workflow","text":"Agent choose action from the action space of an environment. The environment does the calculation and update and generate events. At the end of each action, if the action affect a vessel, use push_event_to_queue() to push the event into the vessel, if no event generated, call the function with events=None. With push_event_to_queue() called, events are pushed into the vessel. _update_materials is automatically called and perform events in the events_queue. Each event has a corresponding event function, it first update properties of the vessel, then loop over the materials inside the vessel by calling the corresponding event functions of each material. The materials' event function will return feedback by calling the push_event_to_queue(), which contains feedback and unfinished event The returned feedback is added to the _feedback_queue The the _merge_event_queue() is called on _feedback_queue, which merge the events in the feedback_queue to generate a merged_queue and add default event into it, then empty the _feedback_queue Then the merged_queue will be executed and new feedback are collected and added to _feedback_queue, which will be executed with the next action.","title":"The Workflow"},{"location":"vessel_lesson/#event-functions","text":"Function Name Description 'pour by volume' Pour from self vessel to target vessel by certain volume 'drain by pixel Drain from self vessel to target vessel by certain pixel 'fully mix' Shake self vessel to fully mix 'update material dict' Use input to update self vessel's material_dict 'update solute dict' Use input to update self vessel's solute_dict 'mix' Shake vessel of let vessel settle 'update_layer' Update self vessel's layer representation","title":"Event Functions"}]}